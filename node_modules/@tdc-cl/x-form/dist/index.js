function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _ = _interopDefault(require('lodash'));
var React = require('react');
var React__default = _interopDefault(React);
var Immutable = require('immutable');
var Immutable__default = _interopDefault(Immutable);
var deepExtend = _interopDefault(require('deep-extend'));
var _$1 = _interopDefault(require('lodash/fp'));
var autoBind = _interopDefault(require('auto-bind'));
var jsJoda = require('js-joda');
var decimal_js = require('decimal.js');

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function isBeing(obj) {
  return _.isFunction(obj === null || obj === void 0 ? void 0 : obj.is);
}

var Result = function Result() {};

function isResultType(x) {
  return x === Valid || x === Invalid;
}

var $Valid = /*#__PURE__*/function (_Result) {
  _inheritsLoose($Valid, _Result);

  function $Valid(value) {
    var _this;

    _this = _Result.call(this) || this;
    _this.value = value;
    return _this;
  }

  var _proto = $Valid.prototype;

  _proto.equals = function equals(other) {
    return other instanceof Valid && Immutable__default.is(this.value, other.value);
  };

  _proto.hashCode = function hashCode() {
    return Immutable__default.hash(this.value);
  };

  _proto.map = function map(fn) {
    return Valid(fn(this.value));
  };

  _proto.chain = function chain(fn) {
    return fn(this.value);
  };

  _proto.unwrap = function unwrap(_errorMessage) {
    return this.value;
  };

  _proto.is = function is(arg) {
    if (isResultType(arg)) {
      return arg === Valid;
    }

    if (_.isFunction(arg)) {
      return arg(this.value);
    }

    if (isBeing(this.value)) {
      return this.value.is(arg);
    }

    return Immutable__default.is(this.value, arg);
  };

  return $Valid;
}(Result);

function Valid(value) {
  return new $Valid(value);
}
Valid.prototype = $Valid.prototype;

var $Invalid = /*#__PURE__*/function (_Result2) {
  _inheritsLoose($Invalid, _Result2);

  function $Invalid(message) {
    var _this2;

    _this2 = _Result2.call(this) || this;
    _this2.message = message;
    return _this2;
  }

  var _proto2 = $Invalid.prototype;

  _proto2.equals = function equals(other) {
    return other instanceof Invalid && this.message === other.message;
  };

  _proto2.hashCode = function hashCode() {
    return Immutable__default.hash(this.message);
  };

  _proto2.map = function map(_fn) {
    return this.cast();
  };

  _proto2.chain = function chain(_fn) {
    return this.cast();
  };

  _proto2.unwrap = function unwrap(errorMessage) {
    throw new UnwrapError(errorMessage != null ? errorMessage : 'Attempted to unwrap an Invalid result', this);
  };

  _proto2.is = function is(arg) {
    return arg === Invalid;
  };

  _proto2.cast = function cast() {
    return this;
  };

  return $Invalid;
}(Result);

function Invalid(message) {
  return new $Invalid(message);
}
Invalid.prototype = $Invalid.prototype;
var UnwrapError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(UnwrapError, _Error);

  function UnwrapError(message, result) {
    var _this3;

    _this3 = _Error.call(this, message) || this;
    _this3.result = result;
    return _this3;
  }

  return UnwrapError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var Option = /*#__PURE__*/function () {
  function Option(option) {
    this.value = option.value;
    this.label = option.label;
  }

  var _proto = Option.prototype;

  _proto.toJSON = function toJSON() {
    return this.value;
  };

  _proto.equals = function equals(other) {
    return other instanceof Option && Immutable__default.is(this.value, other.value) && Immutable__default.is(this.label, other.label);
  };

  _proto.hashCode = function hashCode() {
    return Immutable__default.hash(this.value) ^ Immutable__default.hash(this.label);
  };

  _proto.is = function is(s) {
    return this.value === s || this.label === s;
  };

  return Option;
}();
var OptionWithProps = /*#__PURE__*/function (_Option) {
  _inheritsLoose(OptionWithProps, _Option);

  function OptionWithProps(option, inputProps, labelProps) {
    var _this;

    _this = _Option.call(this, option) || this;
    _this.option = option;
    _this.inputProps = inputProps;
    _this.labelProps = labelProps;
    return _this;
  }

  return OptionWithProps;
}(Option);

function isReactElement(x) {
  return React__default.isValidElement(x);
}
function removeExcessWhitespace(input) {
  return input.trim().replace(/  +/g, ' ');
}
var single = "'";
var _double = '"';
function quote(s, preferredQuote) {
  if (preferredQuote === void 0) {
    preferredQuote = _double;
  }

  if ([single, _double].includes(preferredQuote) && s.includes(preferredQuote)) {
    var alternativeQuote = preferredQuote === _double ? single : _double;

    if (s.includes(alternativeQuote)) {
      return preferredQuote + s.replace(new RegExp(alternativeQuote, 'g'), '\\' + alternativeQuote) + preferredQuote;
    }

    return alternativeQuote + s + alternativeQuote;
  }

  return preferredQuote + s + preferredQuote;
}
function scrollToTop() {
  window.scrollTo({
    top: 0,
    behavior: 'smooth'
  });
}

var setForm = Symbol('setForm');
var describe = Symbol('describe');
var Field = /*#__PURE__*/function () {
  function Field(locale, defaults, config, name, input, containerRef, inputRef, textAreaRef, theme, subFields) {
    var _this$methods$nonZero,
        _this$methods$allowNe,
        _this = this;

    this.locale = locale;
    this.defaults = defaults;
    this.config = config;
    this.name = name;
    this.input = input;
    this.containerRef = containerRef;
    this.inputRef = inputRef;
    this.textAreaRef = textAreaRef;
    this.theme = theme;
    this.subFields = subFields;
    this.defaultOptions = [];
    this.defaultBlankResult = Invalid(this.locale.fieldIsRequired);
    this.defaultBlankOption = this.locale.selectAnOption;
    this.defaultMethods = {
      options: this.defaultOptions,
      preprocess: this.defaultPreprocess,
      isBlank: this.defaultIsBlank,
      blankResult: this.defaultBlankResult,
      blankOption: this.defaultBlankOption,
      isFocused: this.defaultIsFocused,
      showRule: this.defaultShowRule
    };
    this.methods = _.merge({}, this.defaultMethods, this.defaults, this.config);
    this.label = this.methods.label;
    this.preprocess = this.methods.preprocess.bind(this);
    this.isBlank = this.methods.isBlank.bind(this);
    this.blankResult = this.methods.blankResult;
    this.blankOption = this.methods.blankOption;
    this.parse = this.methods.parse.bind(this);
    this.validate = this.methods.validate.bind(this);
    this.category = this.methods.category;
    this.nonZero = (_this$methods$nonZero = this.methods.nonZero) != null ? _this$methods$nonZero : false;
    this.allowNegative = (_this$methods$allowNe = this.methods.allowNegative) != null ? _this$methods$allowNe : false;
    this.getIsFocused = this.methods.isFocused.bind(this);
    this.showRule = this.methods.showRule.bind(this);
    this.isOptional = this.blankResult instanceof Valid;
    this.inputProps = this.computeInputProps();
    this.textAreaProps = this.inputProps;
    this.options = this.input.options.map(function (option) {
      var inputProps = _this.optionInputProps(option);

      var labelProps = {
        htmlFor: inputProps.id
      };
      return new OptionWithProps(option, inputProps, labelProps);
    });

    _.forEach(subFields, function (subField) {
      subField.superField = _this;
    });
  }

  var _proto = Field.prototype;

  _proto[setForm] = function (form) {
    this._form = form;

    _.forEach(this.subFields, function (subField) {
      subField[setForm](form);
    });
  };

  _proto.defaultPreprocess = function defaultPreprocess(input) {
    return input;
  };

  _proto.defaultIsBlank = function defaultIsBlank(input) {
    return Immutable__default.is(input, this.defaults.blankInput);
  };

  _proto.defaultIsFocused = function defaultIsFocused() {
    return this.input.isFocused;
  };

  _proto.defaultShowRule = function defaultShowRule() {
    return true;
  };

  _proto.computeInputProps = function computeInputProps() {
    var field = this;
    var config = field.config,
        defaults = field.defaults,
        name = field.name,
        input = field.input;
    var defaultInputProps = {
      id: name,
      name: name
    };

    if (typeof input.value === 'boolean') {
      defaultInputProps.checked = input.value;
    } else {
      defaultInputProps.value = input.value;
    }

    var eventHandlers = {
      onChange: function onChange(event) {
        var _defaults$inputProps, _defaults$inputProps$, _defaults$inputProps$2, _config$inputProps, _config$inputProps$on, _config$inputProps$on2;

        field.defaultOnChange(event);
        (_defaults$inputProps = defaults.inputProps) === null || _defaults$inputProps === void 0 ? void 0 : (_defaults$inputProps$ = _defaults$inputProps.onChange) === null || _defaults$inputProps$ === void 0 ? void 0 : (_defaults$inputProps$2 = _defaults$inputProps$.bind(field)) === null || _defaults$inputProps$2 === void 0 ? void 0 : _defaults$inputProps$2(event);
        (_config$inputProps = config.inputProps) === null || _config$inputProps === void 0 ? void 0 : (_config$inputProps$on = _config$inputProps.onChange) === null || _config$inputProps$on === void 0 ? void 0 : (_config$inputProps$on2 = _config$inputProps$on.bind(field)) === null || _config$inputProps$on2 === void 0 ? void 0 : _config$inputProps$on2(event);
      },
      onFocus: function onFocus(event) {
        var _defaults$inputProps2, _defaults$inputProps3, _defaults$inputProps4, _config$inputProps2, _config$inputProps2$o, _config$inputProps2$o2;

        field.defaultOnFocus(event);
        (_defaults$inputProps2 = defaults.inputProps) === null || _defaults$inputProps2 === void 0 ? void 0 : (_defaults$inputProps3 = _defaults$inputProps2.onFocus) === null || _defaults$inputProps3 === void 0 ? void 0 : (_defaults$inputProps4 = _defaults$inputProps3.bind(field)) === null || _defaults$inputProps4 === void 0 ? void 0 : _defaults$inputProps4(event);
        (_config$inputProps2 = config.inputProps) === null || _config$inputProps2 === void 0 ? void 0 : (_config$inputProps2$o = _config$inputProps2.onFocus) === null || _config$inputProps2$o === void 0 ? void 0 : (_config$inputProps2$o2 = _config$inputProps2$o.bind(field)) === null || _config$inputProps2$o2 === void 0 ? void 0 : _config$inputProps2$o2(event);
      },
      onBlur: function onBlur(event) {
        var _defaults$inputProps5, _defaults$inputProps6, _defaults$inputProps7, _config$inputProps3, _config$inputProps3$o, _config$inputProps3$o2;

        field.defaultOnBlur(event);
        (_defaults$inputProps5 = defaults.inputProps) === null || _defaults$inputProps5 === void 0 ? void 0 : (_defaults$inputProps6 = _defaults$inputProps5.onBlur) === null || _defaults$inputProps6 === void 0 ? void 0 : (_defaults$inputProps7 = _defaults$inputProps6.bind(field)) === null || _defaults$inputProps7 === void 0 ? void 0 : _defaults$inputProps7(event);
        (_config$inputProps3 = config.inputProps) === null || _config$inputProps3 === void 0 ? void 0 : (_config$inputProps3$o = _config$inputProps3.onBlur) === null || _config$inputProps3$o === void 0 ? void 0 : (_config$inputProps3$o2 = _config$inputProps3$o.bind(field)) === null || _config$inputProps3$o2 === void 0 ? void 0 : _config$inputProps3$o2(event);
      }
    };
    return deepExtend(defaultInputProps, _.merge({}, defaults.inputProps, {
      placeholder: defaults.placeholder
    }), _.merge({}, config.inputProps, {
      placeholder: config.placeholder
    }), eventHandlers);
  };

  _proto.defaultOnChange = function defaultOnChange(event) {
    if (typeof this.input.value === 'boolean') {
      this.input.setValue(event.target.checked);
    }

    if (typeof event.target.value !== typeof this.input.value) {
      return;
    }

    this.input.setValue(event.target.value);
  };

  _proto.defaultOnFocus = function defaultOnFocus(_event) {
    this.input.setIsFocused(true);
  };

  _proto.defaultOnBlur = function defaultOnBlur(_event) {
    this.input.setIsFocused(false);
    this.input.setHasBeenBlurred(true);
  };

  _proto.computeResult = function computeResult() {
    var preprocess = this.preprocess,
        isBlank = this.isBlank,
        blankResult = this.blankResult,
        parse = this.parse,
        input = this.input,
        validate = this.validate;
    var input_ = preprocess(input.value);

    if (isBlank(input_)) {
      return blankResult;
    }

    return parse(input_).chain(validate);
  };

  _proto.is = function is(arg) {
    return this.result.is(arg);
  };

  Field.getValueAssumingItIsValid = function getValueAssumingItIsValid(field) {
    return field.result.unwrap("Couldn't get the value of the " + field[describe]() + " because it's invalid");
  };

  _proto[describe] = function () {
    var label = this.label,
        name = this.name;
    var tilde = '`';

    if (label == null || isReactElement(label) || removeExcessWhitespace(label) === '') {
      return "field at " + quote(name, tilde);
    }

    return "field " + quote(label) + " (" + quote(name, tilde) + ")";
  };

  _proto.optionInputProps = function optionInputProps(option) {
    var _this$defaults$option, _this$defaults$option2, _this$config$optionIn, _this$config$optionIn2;

    return _extends({}, this.defaultOptionInputProps(option), (_this$defaults$option = this.defaults.optionInputProps) === null || _this$defaults$option === void 0 ? void 0 : (_this$defaults$option2 = _this$defaults$option.call) === null || _this$defaults$option2 === void 0 ? void 0 : _this$defaults$option2.call(_this$defaults$option, this, option), (_this$config$optionIn = this.config.optionInputProps) === null || _this$config$optionIn === void 0 ? void 0 : (_this$config$optionIn2 = _this$config$optionIn.call) === null || _this$config$optionIn2 === void 0 ? void 0 : _this$config$optionIn2.call(_this$config$optionIn, this, option));
  };

  _proto.defaultOptionInputProps = function defaultOptionInputProps(option) {
    return _extends({}, this.inputProps, {
      id: this.name + "_" + option.value,
      checked: this.input.value === option.value,
      value: option.value
    });
  };

  _proto.render = function render() {
    if (!this.shouldBeShown) {
      return null;
    }

    var Field = this.theme.Field;
    return React.createElement(Field, {
      field: this
    });
  };

  _proto.focus = function focus(options) {
    var _this$inputRef$curren;

    var element = (_this$inputRef$curren = this.inputRef.current) != null ? _this$inputRef$curren : this.textAreaRef.current;

    if (element == null) {
      console.error("I tried to focus the " + this[describe]() + " but it doesn't have an inputRef or textAreaRef");
      return;
    }

    element.focus(options);
  };

  _proto.fillWith = function fillWith(data) {
    var input = this.acceptExternal(data);

    if (input !== undefined) {
      this.input.setValue(input);
    }
  };

  _proto.acceptExternal = function acceptExternal(data) {
    var _this$methods$acceptE, _this$methods;

    if (data === undefined) {
      return undefined;
    }

    if (data === null) {
      return this.defaults.blankInput;
    }

    var input = (_this$methods$acceptE = (_this$methods = this.methods).acceptExternal) === null || _this$methods$acceptE === void 0 ? void 0 : _this$methods$acceptE.call(_this$methods, data);

    if (input !== undefined) {
      return input;
    }

    if (data.constructor === this.input.value.constructor) {
      return data;
    }
  };

  _proto.reset = function reset() {
    this.input.setValue(this.input.initialValue);
    this.input.setHasBeenBlurred(false);

    _.forEach(this.subFields, function (subField) {
      subField.reset();
    });
  };

  _createClass(Field, [{
    key: "form",
    get: function get() {
      if (this._form === undefined) {
        throw new Error("Tried to access parent form before initialization");
      }

      return this._form;
    }
  }, {
    key: "result",
    get: function get() {
      if (this._result == null) {
        this._result = this.computeResult();
      }

      return this._result;
    }
  }, {
    key: "isValid",
    get: function get() {
      return this.is(Valid);
    }
  }, {
    key: "shouldBeShown",
    get: function get() {
      return this.showRule(this.form.fields);
    }
  }, {
    key: "isFocused",
    get: function get() {
      return this.getIsFocused();
    }
  }]);

  return Field;
}();
function scrollToField(field) {
  if (field.containerRef.current == null) {
    scrollToTop();
    console.error("I tried to scroll to the " + field[describe]() + ", " + "but it doesn't have a containerRef to scroll to");
    return false;
  }

  field.containerRef.current.scrollIntoView({
    behavior: 'smooth'
  });
  return true;
}

function useMountEffect(effect) {
  React.useEffect(effect, []);
}

function useInputState(initialValue, optionsObject) {
  var _useState = React.useState(initialValue),
      value = _useState[0],
      setValue = _useState[1];

  var _useState2 = React.useState(false),
      isFocused = _useState2[0],
      setIsFocused = _useState2[1];

  var _useState3 = React.useState(false),
      hasBeenBlurred = _useState3[0],
      setHasBeenBlurred = _useState3[1];

  var _useState4 = React.useState(isAsync(optionsObject)),
      isLoading = _useState4[0],
      setIsLoading = _useState4[1];

  var _useState5 = React.useState(null),
      error = _useState5[0],
      setError = _useState5[1];

  var _useState6 = React.useState(isAsync(optionsObject) ? [] : optionsObject.map(parseOption)),
      options = _useState6[0],
      setOptions = _useState6[1];

  useMountEffect(function () {
    if (isAsync(optionsObject)) {
      optionsObject().then(_$1.map(parseOption)).then(setOptions)["catch"](setError)["finally"](function () {
        return setIsLoading(false);
      });
    }
  });
  return {
    value: value,
    setValue: setValue,
    isFocused: isFocused,
    setIsFocused: setIsFocused,
    hasBeenBlurred: hasBeenBlurred,
    setHasBeenBlurred: setHasBeenBlurred,
    isLoading: isLoading,
    error: error,
    options: options,
    initialValue: initialValue
  };
}

function isAsync(options) {
  return _$1.isFunction(options);
}

function parseOption(option) {
  if (typeof option === 'string') {
    return new Option({
      value: option,
      label: option
    });
  }

  return new Option(option);
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

var defaultTheme = {
  Field: function Field(_ref) {
    var field = _ref.field,
        className = _ref.className;
    var _field$theme = field.theme,
        FieldContainer = _field$theme.FieldContainer,
        Label = _field$theme.Label,
        Input = _field$theme.Input,
        Message = _field$theme.Message;
    return React__default.createElement(FieldContainer, {
      field: field,
      className: className
    }, React__default.createElement(Label, {
      field: field
    }), React__default.createElement(Input, {
      field: field
    }), React__default.createElement(Message, {
      field: field
    }));
  },
  FieldContainer: function FieldContainer(_ref2) {
    var field = _ref2.field,
        className = _ref2.className,
        children = _ref2.children;
    return React__default.createElement("div", {
      className: className,
      style: {
        marginBottom: '1em'
      },
      ref: field.containerRef
    }, children);
  },
  Label: function Label(_ref3) {
    var field = _ref3.field,
        className = _ref3.className;
    var label = field.label,
        inputProps = field.inputProps,
        theme = field.theme;
    var Optional = theme.Optional;

    if (label != null) {
      return React__default.createElement("label", {
        htmlFor: inputProps.id,
        className: className
      }, label, React__default.createElement(Optional, {
        field: field
      }));
    }

    return null;
  },
  Optional: function Optional(_ref4) {
    var field = _ref4.field,
        className = _ref4.className;

    if (field.isOptional) {
      return React__default.createElement("em", {
        className: className,
        style: {
          color: '#585858'
        }
      }, ' ', "(", field.locale.optional, ")");
    }

    return null;
  },
  Input: function Input(_ref5) {
    var field = _ref5.field,
        className = _ref5.className;
    return React__default.createElement("input", Object.assign({}, field.inputProps, {
      className: classnames(field.inputProps.className, className),
      ref: field.inputRef
    }));
  },
  Message: function Message(_ref6) {
    var field = _ref6.field,
        className = _ref6.className;
    var result = field.result,
        input = field.input,
        form = field.form,
        theme = field.theme;
    var Error = theme.Error;

    if (result instanceof Invalid && (input.hasBeenBlurred || form.hasBeenSubmitted)) {
      return React__default.createElement(Error, {
        field: field,
        className: className
      }, result.message);
    }

    return null;
  },
  Error: function Error(_ref7) {
    var className = _ref7.className,
        children = _ref7.children;
    return React__default.createElement("small", {
      className: className,
      style: {
        color: '#b60000',
        fontWeight: 600
      }
    }, children);
  }
};
function injectClassNames(theme, injectedClassNames) {
  return _.mapValues(theme, function (OriginalComponent, componentName) {
    return function ComponentWithInjectedClassName(props) {
      return React__default.createElement(OriginalComponent, {
        field: props.field,
        className: classnames(injectedClassNames[componentName], props.className)
      }, props.children);
    };
  });
}

var english = {
  selectAnOption: '--- Select an option ---',
  optional: 'Optional',
  fieldIsRequired: 'Required field',
  invalidNumber: 'Invalid number',
  mustBeInt: 'Must be an integer number',
  tooManyDecimals: function tooManyDecimals(maxDecimals) {
    return "No more than " + maxDecimals + " decimals allowed";
  },
  negative: "Can't be a negative number",
  tooSmall: function tooSmall(min) {
    return "Must be at least " + min;
  },
  tooBig: function tooBig(max) {
    return "Must be at most " + max;
  },
  cantBeZero: "Can't be zero",
  invalidDate: 'Invalid date',
  invalidTime: 'Invalid time',
  loading: 'Loading...'
};
var spanish = {
  selectAnOption: '--- Seleccione una opción ---',
  optional: 'Opcional',
  fieldIsRequired: 'Campo requerido',
  invalidNumber: 'Número inválido',
  mustBeInt: 'Debe ser un número entero',
  tooManyDecimals: function tooManyDecimals(maxDecimals) {
    return "No se permite m\xE1s de " + maxDecimals + " decimales";
  },
  negative: 'No puede ser negativo',
  tooSmall: function tooSmall(min) {
    return "Debe ser al menos " + min;
  },
  tooBig: function tooBig(max) {
    return "Debe ser a lo m\xE1s " + max;
  },
  cantBeZero: 'No puede ser 0',
  invalidDate: 'Fecha inválida',
  invalidTime: 'Hora inválida',
  loading: 'Cargando...'
};

var XFormContext = React.createContext({
  locale: english
});

var FieldSpec = /*#__PURE__*/function () {
  function FieldSpec(config, defaults) {
    this.config = config;
    this.defaults = defaults;
  }

  var _proto = FieldSpec.prototype;

  _proto["with"] = function _with(config) {
    return new FieldSpec(_.merge({}, this.config, config), this.defaults);
  };

  _proto.readOnly = function readOnly() {
    return this.readOnlyIf(true);
  };

  _proto.editable = function editable() {
    return this.readOnlyIf(false);
  };

  _proto.readOnlyIf = function readOnlyIf(condition) {
    return this["with"]({
      inputProps: {
        readOnly: condition,
        disabled: condition,
        'aria-readonly': condition,
        'aria-disabled': condition
      }
    });
  };

  _proto.showIf = function showIf(rule) {
    return this["with"]({
      showRule: rule
    });
  };

  return FieldSpec;
}();
function useField(field, name) {
  var _ref, _field$config$options, _ref2, _field$config$initial, _field$defaults$subFi;

  var _useContext = React.useContext(XFormContext),
      locale = _useContext.locale;

  var optionsMethod = (_ref = (_field$config$options = field.config.options) != null ? _field$config$options : field.defaults.options) != null ? _ref : [];
  var input = useInputState((_ref2 = (_field$config$initial = field.config.initialInput) != null ? _field$config$initial : field.defaults.initialInput) != null ? _ref2 : field.defaults.blankInput, optionsMethod);
  var containerRef = React.useRef(null);
  var inputRef = React.useRef(null);
  var textAreaRef = React.useRef(null);
  var theme = React.useMemo(function () {
    var theme = _.merge({}, defaultTheme, field.defaults.render, field.config.render);

    var injectedClassNames = _.merge({}, field.defaults.classNames, field.config.classNames);

    return injectClassNames(theme, injectedClassNames);
  }, []);

  var subFields = _.mapValues((_field$defaults$subFi = field.defaults.subFields) != null ? _field$defaults$subFi : {}, useField);

  return new Field(locale, field.defaults, field.config, name, input, containerRef, inputRef, textAreaRef, theme, subFields);
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

// Asynchronously await a promise and pass the result to a finally continuation
function _finallyRethrows(body, finalizer) {
	try {
		var result = body();
	} catch (e) {
		return finalizer(true, e);
	}
	if (result && result.then) {
		return result.then(finalizer.bind(null, false), finalizer.bind(null, true));
	}
	return finalizer(false, result);
}

var setIsSubmitting = Symbol('setIsSubmitting');
var setHasBeenSubmitted = Symbol('setHasBeenSubmitted');
var setSubmitError = Symbol('setSubmitError');
function useFormState() {
  var _ref;

  var _useState = React.useState(false),
      isSubmitting = _useState[0],
      setIsSubmitting_ = _useState[1];

  var _useState2 = React.useState(false),
      hasBeenSubmitted = _useState2[0],
      setHasBeenSubmitted_ = _useState2[1];

  var _useState3 = React.useState(null),
      submitError = _useState3[0],
      setSubmitError_ = _useState3[1];

  return _ref = {
    isSubmitting: isSubmitting
  }, _ref[setIsSubmitting] = setIsSubmitting_, _ref.hasBeenSubmitted = hasBeenSubmitted, _ref[setHasBeenSubmitted] = setHasBeenSubmitted_, _ref.submitError = submitError, _ref[setSubmitError] = setSubmitError_, _ref;
}

var Submitter = /*#__PURE__*/function () {
  function Submitter(config) {
    var _this$config$onError;

    this.config = config;
    this.onValid = this.config.onValid;
    this.onError = (_this$config$onError = this.config.onError) != null ? _this$config$onError : Submitter.defaultOnError;
  }

  var _proto = Submitter.prototype;

  _proto[setForm] = function (form) {
    this._form = form;
  };

  _proto.computeButtonProps = function computeButtonProps() {
    var config = this.config,
        form = this.form;
    return _extends({
      type: 'submit',
      disabled: config.onInvalid === 'disable' && !form.isValid
    }, this.config.buttonProps);
  };

  _proto.render = function render() {
    return _render(this);
  };

  _proto.submit = function submit(form) {
    try {
      var _this2 = this;

      form.state[setHasBeenSubmitted](true);

      if (!form.isValid) {
        return Promise.resolve(_this2.onInvalid(form));
      }

      var values = form.getValuesAssumingTheyAreValid();
      form.state[setSubmitError](null);
      form.state[setIsSubmitting](true);

      var _temp2 = _finallyRethrows(function () {
        return _catch(function () {
          return Promise.resolve(_this2.onValid(values)).then(function () {});
        }, function (err) {
          form.state[setSubmitError](err);

          _this2.onError(err, form);
        });
      }, function (_wasThrown, _result) {
        form.state[setIsSubmitting](false);
        if (_wasThrown) throw _result;
        return _result;
      });

      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function () {}) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.onInvalid = function onInvalid(form) {
    if (this.config.onInvalid === 'disable') {
      return;
    }

    if (_.isFunction(this.config.onInvalid)) {
      this.config.onInvalid(form);
      return;
    }

    return Submitter.defaultOnInvalid(form);
  };

  Submitter.defaultOnInvalid = function defaultOnInvalid(form) {
    var firstInvalidField = _.find(form.fields, function (field) {
      return !field.isValid;
    });

    if (firstInvalidField == null) {
      scrollToTop();
      return;
    }

    firstInvalidField.focus({
      preventScroll: scrollToField(firstInvalidField)
    });
  };

  Submitter.defaultOnError = function defaultOnError(err) {
    throw err;
  };

  _createClass(Submitter, [{
    key: "form",
    get: function get() {
      if (this._form === undefined) {
        throw new Error("Tried to access parent form before initialization");
      }

      return this._form;
    }
  }, {
    key: "buttonProps",
    get: function get() {
      if (this._buttonProps == null) {
        this._buttonProps = this.computeButtonProps();
      }

      return this._buttonProps;
    }
  }]);

  return Submitter;
}();

function _render(_ref) {
  var config = _ref.config,
      buttonProps = _ref.buttonProps;
  return React__default.createElement("button", Object.assign({}, buttonProps), config.label);
}

var $Submitter = /*#__PURE__*/function () {
  function $Submitter(config) {
    this.config = config;
  }

  var _proto = $Submitter.prototype;

  _proto["with"] = function _with(config) {
    return new $Submitter(_.merge({}, this.config, config));
  };

  return $Submitter;
}();
function useSubmitter(submitter) {
  return new Submitter(submitter.config);
}

var Form = /*#__PURE__*/function () {
  function Form(config, fields, submitter, state) {
    var _this = this;

    this.config = config;
    this.fields = fields;
    this.submitter = submitter;
    this.state = state;
    this.hasBeenSubmitted = this.state.hasBeenSubmitted;
    this.props = Form.propsFor(this);
    this.lazyShownFields = lazy(function () {
      return _.pickBy(_this.fields, 'shouldBeShown');
    });
    this.lazyIsValid = lazy(function () {
      return _.every(_this.shownFields, 'isValid');
    });

    _.forEach(fields, function (field) {
      return field[setForm](_this);
    });

    submitter[setForm](this);
    autoBind(this);
  }

  Form.propsFor = function propsFor(form) {
    return _extends({
      onSubmit: function onSubmit(event) {
        event.preventDefault();
        form.submit().then();
      }
    }, form.config.props);
  };

  var _proto = Form.prototype;

  _proto.fillWith = function fillWith(data) {
    var _this2 = this;

    _.forEach(data, function (value, key) {
      var _this2$fields$key;

      (_this2$fields$key = _this2.fields[key]) === null || _this2$fields$key === void 0 ? void 0 : _this2$fields$key.fillWith(value);
    });
  };

  _proto.render = function render() {
    return React__default.createElement("form", Object.assign({}, this.props), this.renderFields(), this.renderSubmit());
  };

  _proto.renderFields = function renderFields() {
    return React__default.createElement(React__default.Fragment, null, _.map(this.fields, function (field) {
      return React__default.createElement(React__default.Fragment, {
        key: field.name
      }, field.render());
    }));
  };

  _proto.renderSubmit = function renderSubmit() {
    return this.submitter.render();
  };

  _proto.submit = function submit() {
    try {
      var _this4 = this;

      return Promise.resolve(_this4.submitter.submit(_this4));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getValuesAssumingTheyAreValid = function getValuesAssumingTheyAreValid() {
    return _.mapValues(this.shownFields, Field.getValueAssumingItIsValid);
  };

  _proto.reset = function reset() {
    _.forEach(this.fields, function (field) {
      return field.reset();
    });

    this.state[setHasBeenSubmitted](false);
    this.state[setSubmitError](null);
  };

  _createClass(Form, [{
    key: "shownFields",
    get: function get() {
      return this.lazyShownFields();
    }
  }, {
    key: "isValid",
    get: function get() {
      return this.lazyIsValid();
    }
  }]);

  return Form;
}();

function lazy(init) {
  var value = UNINITIALIZED;
  return function () {
    if (value === UNINITIALIZED) {
      value = init();
    }

    return value;
  };
}

var UNINITIALIZED = Symbol('UNINITIALIZED');

var _$Form = /*#__PURE__*/function () {
  function _$Form(config) {
    this.config = config;
  }

  var _proto = _$Form.prototype;

  _proto["with"] = function _with(config) {
    return $Form(_.merge({}, this.config, config));
  };

  _proto.each = function each(fieldTransform) {
    return this["with"]({
      fields: _.mapValues(this.config.fields, fieldTransform)
    });
  };

  _proto.readOnly = function readOnly() {
    return this.each(function (field) {
      return field.readOnly();
    })["with"]({
      submit: this.config.submit["with"]({
        buttonProps: {
          disabled: true,
          'aria-disabled': true
        }
      })
    });
  };

  return _$Form;
}();

function $Form(config) {
  return new _$Form(config);
}
$Form.prototype = _$Form.prototype;
function useForm(form) {
  var state = useFormState();

  if (state.isSubmitting) {
    form = form.readOnly();
  }

  var _form = form,
      config = _form.config;

  var fields = _.mapValues(config.fields, useField);

  var submitter = useSubmitter(config.submit);
  return new Form(config, fields, submitter, state);
}

function makeCustomField() {
  function CustomField(defaults) {
    function $CustomField(arg) {
      if (arg == null) {
        return $CustomField({});
      }

      if (typeof arg === 'string') {
        return $CustomField({
          label: arg
        });
      }

      if (isReactElement(arg)) {
        return $CustomField({
          label: arg
        });
      }

      return new FieldSpec(arg, defaults);
    }

    $CustomField.defaults = defaults;
    return $CustomField;
  }

  CustomField["extends"] = function (base) {
    return {
      "with": function _with(extension) {
        return CustomField(deepExtend({}, base.defaults, extension));
      }
    };
  };

  CustomField.composite = function (subFields) {
    return {
      "with": function _with(extension) {
        var defaults = {
          subFields: _.mapValues(subFields, function (subField, name) {
            return subField["with"]({
              inputProps: {
                onChange: function onChange(event) {
                  var value = event.target.value;
                  this.superField.input.setValue(function (prev) {
                    var _extends2;

                    return _extends({}, prev, (_extends2 = {}, _extends2[name] = value, _extends2));
                  });
                },
                onBlur: function onBlur() {
                  this.superField.input.setHasBeenBlurred(true);
                }
              }
            });
          }),
          blankInput: _.mapValues(subFields, 'defaults.blankInput'),
          isBlank: function isBlank(inputs) {
            return _.some(zipValues(inputs, this.subFields), function (_ref) {
              var input = _ref[0],
                  subField = _ref[1];
              return subField.isBlank(input);
            });
          },
          isFocused: function isFocused() {
            return _.some(this.subFields, 'isFocused');
          },
          parse: function parse(inputs) {
            try {
              return Valid(_.chain(zipValues(inputs, this.subFields)).mapValues(function (_ref2) {
                var input = _ref2[0],
                    subField = _ref2[1];
                return subField.parse(input).unwrap();
              }).value());
            } catch (err) {
              if (err instanceof UnwrapError) return err.result;
              throw err;
            }
          },
          validate: function validate(values) {
            try {
              return Valid(_.chain(zipValues(values, this.subFields)).mapValues(function (_ref3) {
                var value = _ref3[0],
                    subField = _ref3[1];
                return subField.validate(value).unwrap();
              }).value());
            } catch (err) {
              if (err instanceof UnwrapError) return err.result;
              throw err;
            }
          },
          render: {
            Input: function Input(_ref4) {
              var field = _ref4.field;
              return React__default.createElement(React__default.Fragment, null, _.map(field.subFields, function (subField, name) {
                return React__default.createElement(React__default.Fragment, {
                  key: name
                }, subField.render());
              }));
            }
          }
        };
        return CustomField(_.merge(defaults, extension));
      }
    };
  };

  return CustomField;
}

var CustomField = makeCustomField();

function zipValues(a, b) {
  var ans = {};
  Object.keys(a).forEach(function (key) {
    ans[key] = [a[key], b[key]];
  });
  return ans;
}

var checkbox = CustomField({
  category: 'binary',
  blankInput: false,
  isBlank: function isBlank() {
    return false;
  },
  parse: Valid,
  validate: Valid,
  acceptExternal: acceptBoolean,
  inputProps: {
    type: 'checkbox'
  },
  render: {
    Field: function Field(_ref) {
      var field = _ref.field;
      var _field$theme = field.theme,
          FieldContainer = _field$theme.FieldContainer,
          Label = _field$theme.Label,
          Input = _field$theme.Input,
          Message = _field$theme.Message;
      return React__default.createElement(FieldContainer, {
        field: field
      }, React__default.createElement("div", null, React__default.createElement(Input, {
        field: field
      }), React__default.createElement(Label, {
        field: field
      })), React__default.createElement(Message, {
        field: field
      }));
    }
  }
});
function acceptBoolean(data) {
  if (_.isBoolean(data)) {
    return data;
  }

  if (data === 0 || data === 1) {
    return Boolean(data);
  }

  if (_.isString(data)) {
    if (/^true|t|1|yes|y$/i.test(data)) {
      return true;
    }

    if (/^false|f|0|no|n$/i.test(data)) {
      return false;
    }
  }
}

var checklist = CustomField({
  category: 'enum',
  blankInput: Immutable.Set(),
  parse: Valid,
  validate: Valid,
  acceptExternal: acceptSetOfString,
  optionInputProps: function optionInputProps(option) {
    var input = this.input;
    return {
      type: 'checkbox',
      checked: input.value.has(option.value),
      onChange: function onChange(event) {
        input.setValue(toggle(event.target.value));
      }
    };
  },
  render: {
    Input: function Input(_ref) {
      var field = _ref.field;
      return React__default.createElement(React__default.Fragment, null, field.options.map(function (_ref2) {
        var value = _ref2.value,
            labelProps = _ref2.labelProps,
            label = _ref2.label,
            inputProps = _ref2.inputProps;
        return React__default.createElement("div", {
          key: value
        }, React__default.createElement("input", Object.assign({}, inputProps)), React__default.createElement("label", Object.assign({}, labelProps), label));
      }));
    }
  }
});

function acceptSetOfString(data) {
  if (Symbol.iterator in Object(data)) {
    var ans = [];

    for (var _iterator = _createForOfIteratorHelperLoose(data), _step; !(_step = _iterator()).done;) {
      var element = _step.value;

      if (_.isString(element)) {
        ans.push(element);
      }
    }

    return Immutable.Set(ans);
  }

  if (_.isPlainObject(data)) {
    return Immutable.Set(Object.keys(data).filter(function (key) {
      return acceptBoolean(data[key]) === true;
    }));
  }
}

function toggle(element) {
  return function (set) {
    return set.has(element) ? set.remove(element) : set.add(element);
  };
}

var date = CustomField({
  blankInput: '',
  parse: function parse(input) {
    try {
      return Valid(jsJoda.LocalDate.parse(input));
    } catch (err) {
      if (err instanceof jsJoda.DateTimeParseException) {
        return Invalid(this.locale.invalidDate);
      }

      throw err;
    }
  },
  validate: Valid,
  acceptExternal: acceptDate,
  inputProps: {
    type: 'date',
    style: {
      display: 'block'
    }
  }
});

function acceptDate(data) {
  if (data instanceof jsJoda.LocalDate) {
    return data.toString();
  }

  if (_.isString(data)) {
    data = new Date(data);
  }

  if (data instanceof Date) {
    var input = data.toISOString().substr(0, 'YYYY-MM-DD'.length);

    if (input !== 'Invalid Date') {
      return input;
    }
  }
}

var decimal = CustomField({
  category: 'numeric',
  preprocess: removeExcessWhitespace,
  blankInput: '',
  parse: function parse(input) {
    var _inferAllowedDecimals, _this$inputProps$min, _this$inputProps$max;

    var allowedDecimals = (_inferAllowedDecimals = inferAllowedDecimalsFrom(this.inputProps)) != null ? _inferAllowedDecimals : Infinity;
    var defaultMin = this.allowNegative ? -Infinity : 0;
    var min = new decimal_js.Decimal((_this$inputProps$min = this.inputProps.min) != null ? _this$inputProps$min : defaultMin);
    var max = new decimal_js.Decimal((_this$inputProps$max = this.inputProps.max) != null ? _this$inputProps$max : Infinity);
    return parseDecimal(input, allowedDecimals, min, max, this.nonZero, this.allowNegative, this.locale);
  },
  validate: Valid,
  acceptExternal: function acceptExternal(data) {
    if (data instanceof decimal_js.Decimal || _.isNumber(data)) {
      return data.toString();
    }
  },
  inputProps: {
    style: {
      display: 'block'
    }
  }
});
function inferAllowedDecimalsFrom(inputProps) {
  var step = Number(inputProps.step);

  if (1 / step % 10 === 0) {
    return -Math.log10(step);
  }
}
function parseDecimal(input, allowedDecimals, min, max, nonZero, allowNegative, locale) {
  if (!floatRegex.test(input)) {
    return Invalid(locale.invalidNumber);
  }

  if (!allowedDecimals && !integerRegex.test(input)) {
    return Invalid(locale.mustBeInt);
  }

  var value;

  try {
    value = new decimal_js.Decimal(input);
  } catch (_pokemonException) {
    return Invalid(locale.invalidNumber);
  }

  if (value.isNegative() && value.isZero()) {
    value = new decimal_js.Decimal(0);
  }

  if (value.decimalPlaces() > allowedDecimals) {
    return Invalid(locale.tooManyDecimals(allowedDecimals));
  }

  if (value.lessThan(min)) {
    return value.isNegative() && !allowNegative ? Invalid(locale.negative) : Invalid(locale.tooSmall(min));
  }

  if (value.greaterThan(max)) {
    return Invalid(locale.tooBig(max));
  }

  if (nonZero && value.isZero()) {
    return Invalid(locale.cantBeZero);
  }

  return Valid(value);
}
var integerRegex = /^[-+]?\d+$/;
var floatRegex = /^[-+]?\d+(\.\d+)?([Ee][-+]?\d+)?$/;

var number = CustomField({
  category: 'numeric',
  preprocess: removeExcessWhitespace,
  blankInput: '',
  parse: function parse(input) {
    var _inferAllowedDecimals, _this$inputProps$min, _this$inputProps$max;

    var allowedDecimals = (_inferAllowedDecimals = inferAllowedDecimalsFrom(this.inputProps)) != null ? _inferAllowedDecimals : 0;
    var defaultMin = this.allowNegative ? -Infinity : 0;
    var min = new decimal_js.Decimal((_this$inputProps$min = this.inputProps.min) != null ? _this$inputProps$min : defaultMin);
    var max = new decimal_js.Decimal((_this$inputProps$max = this.inputProps.max) != null ? _this$inputProps$max : Infinity);
    return parseDecimal(input, allowedDecimals, min, max, this.nonZero, this.allowNegative, this.locale).map(function (decimal) {
      return decimal.toNumber();
    });
  },
  validate: Valid,
  acceptExternal: function acceptExternal(data) {
    if (_.isNumber(data)) {
      return data.toString();
    }
  },
  inputProps: decimal.defaults.inputProps
});

var text = CustomField({
  category: 'textual',
  preprocess: function preprocess(input) {
    var _this$config$inputPro, _this$config$inputPro2, _this$defaults$inputP;

    var type = (_this$config$inputPro = (_this$config$inputPro2 = this.config.inputProps) === null || _this$config$inputPro2 === void 0 ? void 0 : _this$config$inputPro2.type) != null ? _this$config$inputPro : (_this$defaults$inputP = this.defaults.inputProps) === null || _this$defaults$inputP === void 0 ? void 0 : _this$defaults$inputP.type;

    if (type === 'password') {
      return input;
    }

    return removeExcessWhitespace(input);
  },
  blankInput: '',
  parse: Valid,
  validate: Valid,
  inputProps: {
    style: {
      display: 'block'
    }
  }
});

var password = CustomField["extends"](text)["with"]({
  label: 'Password',
  inputProps: {
    type: 'password'
  },
  preprocess: undefined
});

var select = CustomField({
  category: 'enum',
  blankInput: '',
  parse: function parse(input) {
    return Valid(this.input.options.find(_.matches({
      value: input
    })));
  },
  validate: Valid,
  acceptExternal: acceptOption,
  inputProps: {
    style: {
      display: 'block'
    }
  },
  render: {
    Input: function Input(_ref) {
      var field = _ref.field,
          className = _ref.className;
      return React__default.createElement("select", Object.assign({}, field.inputProps, {
        className: classnames(field.inputProps.className, className)
      }), _.isString(field.blankOption) ? React__default.createElement("option", {
        value: ''
      }, field.blankOption) : field.input.isLoading ? React__default.createElement("option", {
        value: ''
      }, field.locale.loading) : null, field.options.map(function (_ref2) {
        var value = _ref2.value,
            label = _ref2.label;
        return React__default.createElement("option", {
          value: value,
          key: value
        }, label);
      }));
    }
  }
});
function acceptOption(data) {
  if (_.isString(data.value)) {
    return data.value;
  }
}

var radio = CustomField({
  category: 'enum',
  blankInput: '',
  parse: select.defaults.parse,
  validate: Valid,
  acceptExternal: acceptOption,
  inputProps: {
    type: 'radio'
  },
  render: {
    Input: function Input(_ref) {
      var field = _ref.field;
      var options = field.options;
      return React__default.createElement("div", null, options.map(function (option) {
        return React__default.createElement("div", {
          key: option.value
        }, React__default.createElement("input", Object.assign({}, option.inputProps)), React__default.createElement("label", Object.assign({}, option.labelProps), option.label));
      }));
    }
  }
});

var textarea = CustomField["extends"](text)["with"]({
  preprocess: undefined,
  render: {
    Input: function Input(_ref) {
      var field = _ref.field;
      return React__default.createElement("textarea", Object.assign({}, field.textAreaProps, {
        ref: field.textAreaRef
      }));
    }
  }
});

var time = CustomField({
  blankInput: '',
  parse: function parse(input) {
    try {
      return Valid(jsJoda.LocalTime.parse(input));
    } catch (err) {
      if (err instanceof jsJoda.DateTimeParseException) {
        return Invalid(this.locale.invalidTime);
      }

      throw err;
    }
  },
  validate: Valid,
  acceptExternal: function acceptExternal(data) {
    if (data instanceof jsJoda.LocalTime) {
      return data.toString();
    }
  },
  inputProps: {
    type: 'time',
    style: {
      display: 'block'
    }
  }
});

function optional(field) {
  return new FieldSpec(field.config, _extends({}, field.defaults, {
    blankResult: Valid(null)
  }));
}

function button() {
  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {
    return button(arguments.length <= 0 ? undefined : arguments[0], {
      onValid: arguments.length <= 1 ? undefined : arguments[1]
    });
  }

  if (arguments.length === 2) {
    return button(_extends({
      label: arguments.length <= 0 ? undefined : arguments[0]
    }, arguments.length <= 1 ? undefined : arguments[1]));
  }

  return new $Submitter(arguments.length <= 0 ? undefined : arguments[0]);
}

function Debug(_ref) {
  var value = _ref.value;
  return React__default.createElement("pre", {
    style: {
      maxWidth: '40em'
    }
  }, JSON.stringify(value, getReplacer(), '  '));
}

var getReplacer = function getReplacer() {
  var seen = new WeakSet();
  return function (_key, value) {
    var _value$type;

    if (typeof value === 'object' && value !== null && '$$typeof' in value && (_value$type = value.type) !== null && _value$type !== void 0 && _value$type.name) {
      return "<" + value.type.name + "/>";
    }

    if (typeof value === 'object' && value !== null) {
      if (seen.has(value)) {
        return '...';
      }

      seen.add(value);
    }

    return value;
  };
};

exports.$Button = button;
exports.$Checkbox = checkbox;
exports.$Checklist = checklist;
exports.$Date = date;
exports.$Decimal = decimal;
exports.$Field = FieldSpec;
exports.$Form = $Form;
exports.$Number = number;
exports.$Password = password;
exports.$Radio = radio;
exports.$Select = select;
exports.$Submitter = $Submitter;
exports.$Text = text;
exports.$TextArea = textarea;
exports.$Time = time;
exports.CustomField = CustomField;
exports.Debug = Debug;
exports.Field = Field;
exports.FieldSpec = FieldSpec;
exports.Form = Form;
exports.Invalid = Invalid;
exports.Option = Option;
exports.OptionWithProps = OptionWithProps;
exports.Result = Result;
exports.Valid = Valid;
exports.XFormContext = XFormContext;
exports.acceptBoolean = acceptBoolean;
exports.button = button;
exports.checkbox = checkbox;
exports.checklist = checklist;
exports.date = date;
exports.decimal = decimal;
exports.english = english;
exports.number = number;
exports.optional = optional;
exports.password = password;
exports.radio = radio;
exports.removeExcessWhitespace = removeExcessWhitespace;
exports.scrollToField = scrollToField;
exports.select = select;
exports.spanish = spanish;
exports.text = text;
exports.textarea = textarea;
exports.time = time;
exports.useForm = useForm;
//# sourceMappingURL=index.js.map
