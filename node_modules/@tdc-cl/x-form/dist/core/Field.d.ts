import * as React from 'react';
import { ReactElement, RefObject } from 'react';
import { FieldCategory, FieldConfig, FieldDefaults } from './FieldSpec';
import { InputProps, TextAreaProps } from '../utils/htmlProps';
import { InputState } from './useInputState';
import { Invalid, Predicate, Result, ResultType } from './Result';
import { Theme } from './Theme';
import { EnumOption, Option, OptionWithProps } from './EnumOption';
import { Form, FormFields } from './Form';
import { XFormLocale } from './XFormLocale';
export declare const setForm: unique symbol;
export declare const describe: unique symbol;
interface IField<S, T> {
    readonly locale: XFormLocale;
    readonly defaults: FieldDefaults<S, T>;
    readonly config: FieldConfig<S, T>;
    readonly name: string;
    readonly input: InputState<S>;
    readonly containerRef: RefObject<HTMLDivElement>;
    readonly inputRef: RefObject<HTMLInputElement>;
    readonly textAreaRef: RefObject<HTMLTextAreaElement>;
    readonly theme: Theme;
    readonly form: Form<any>;
    readonly category?: FieldCategory;
    readonly nonZero: boolean;
    readonly allowNegative: boolean;
    /** True if the field is optional, i.e was wrapped in an `optional`.
     * By default all built-in builtin are required. */
    readonly isOptional: boolean;
    readonly subFields: FormFields;
    readonly result: Result<T>;
    /** True if the field can be submitted with the current input, i.e. the user
     * input is in the requested format and the corresponding value passes all
     * validations. */
    readonly isValid: boolean;
    is(value: T): boolean;
    is(predicate: Predicate<T>): boolean;
    is(type: ResultType): boolean;
    readonly label?: string | ReactElement;
    readonly inputProps: InputProps;
    readonly textAreaProps: TextAreaProps;
    readonly options: OptionWithProps[];
    [describe](): string;
    preprocess(input: S): S;
    isBlank(input: S): boolean;
    parse(input: S): Result<T>;
    validate(value: T): Result<T>;
    optionInputProps(option: Option): InputProps;
    shouldBeShown: boolean;
    render(): ReactElement | null;
    focus: HTMLInputElement['focus'];
    isFocused: boolean;
    fillWith(data: any): void;
    reset(): void;
}
export declare class Field<S, T> implements IField<S, T> {
    readonly locale: XFormLocale;
    readonly defaults: FieldDefaults<S, T>;
    readonly config: FieldConfig<S, T>;
    readonly name: string;
    readonly input: InputState<S>;
    readonly containerRef: RefObject<HTMLDivElement>;
    readonly inputRef: RefObject<HTMLInputElement>;
    readonly textAreaRef: RefObject<HTMLTextAreaElement>;
    readonly theme: Theme;
    readonly subFields: FormFields;
    constructor(locale: XFormLocale, defaults: FieldDefaults<S, T>, config: FieldConfig<S, T>, name: string, input: InputState<S>, containerRef: RefObject<HTMLDivElement>, inputRef: RefObject<HTMLInputElement>, textAreaRef: RefObject<HTMLTextAreaElement>, theme: Theme, subFields: FormFields);
    private _form;
    get form(): Form<any>;
    [setForm]<T>(form: Form<T>): void;
    private readonly defaultOptions;
    private defaultPreprocess;
    private defaultIsBlank;
    private readonly defaultBlankResult;
    private readonly defaultBlankOption;
    private defaultIsFocused;
    private defaultShowRule;
    private readonly defaultMethods;
    private readonly methods;
    readonly label: string | React.ReactElement<any, string | ((props: any) => React.ReactElement<any, string | any | (new (props: any) => React.Component<any, any, any>)> | null) | (new (props: any) => React.Component<any, any, any>)> | undefined;
    readonly preprocess: ((input: S) => S) & ((input: S) => S);
    readonly isBlank: ((input: S) => boolean) & ((input: S) => boolean);
    readonly blankResult: Invalid<T> & Result<T>;
    readonly blankOption: string;
    readonly parse: (input: S) => Result<T>;
    readonly validate: (value: T) => Result<T>;
    readonly category: "binary" | "textual" | "numeric" | "enum" | undefined;
    readonly nonZero: boolean;
    readonly allowNegative: boolean;
    private readonly getIsFocused;
    private readonly showRule;
    readonly isOptional: boolean;
    readonly inputProps: React.DetailedHTMLProps<React.InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;
    private computeInputProps;
    private defaultOnChange;
    private defaultOnFocus;
    private defaultOnBlur;
    readonly textAreaProps: any;
    private _result?;
    get result(): Result<T>;
    private computeResult;
    get isValid(): boolean;
    /** Checks whether this field is a valid field with the given value,
     * using `Immutable.is` for the equality check.
     *
     * Example
     * ```
     * const form = useForm($Form({
     *     builtin: {
     *         maritalStatus: $Select('Marital status').with({
     *             options: ['Single', 'Married', ...]
     *         }),
     *         ...
     *     },
     *     ...
     * }));
     * const { maritalStatus } = form.builtin;
     * maritalStatus.is('Married')
     * ```
     * */
    is(value: T): boolean;
    /** Checks whether this field is a valid field whose value satisfies
     * the given predicate.
     *
     * Example:
     * ```
     * const { income } = form.builtin;
     * const over9000 = x => x > 9000;
     * income.is(over900)
     * ``` */
    is(predicate: Predicate<T>): boolean;
    /** Checks whether this field is an instance of the given result type.
     *
     * Examples:
     * ```
     * field.is(Valid)
     * field.is(Invalid)
     * ``` */
    is(type: ResultType): boolean;
    static getValueAssumingItIsValid<T>(field: Field<any, T>): T;
    [describe](): string;
    optionInputProps(option: EnumOption): InputProps;
    readonly options: OptionWithProps[];
    private defaultOptionInputProps;
    get shouldBeShown(): boolean;
    render(): ReactElement | null;
    focus(options?: FocusOptions): void;
    get isFocused(): boolean;
    fillWith(data: any): void;
    private acceptExternal;
    reset(): void;
}
export declare function scrollToField<S, T>(field: Field<S, T>): boolean;
export {};
