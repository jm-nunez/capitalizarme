import { ReactElement } from 'react';
import { InputProps } from '../utils/htmlProps';
import { Field } from './Field';
import { Result } from '../Result';
import { Theme } from './Theme';
import { EnumOption } from './EnumOption';
export interface FieldConfig<S, T> {
    readonly label?: string | ReactElement;
    readonly inputProps?: InputProps;
    readonly options?: Options;
    /** For numeric fields, `true` means zero
     * is not a valid value for this field. */
    readonly nonZero?: boolean;
    /** For numeric fields, `true` if negative numbers are valid
     * for this field. By default negative numbers are not valid. */
    readonly allowNegative?: boolean;
    optionInputProps?(option: EnumOption): InputProps;
    preprocess?(input: S): S;
    readonly blankResult?: Result<T>;
    readonly render?: Partial<Theme>;
}
export declare type FieldOption = EnumOption | string;
export declare type Options = FieldOption[] | AsyncOptions;
export declare type AsyncOptions = () => Promise<FieldOption[]>;
interface IFieldSpec<S, T> {
    readonly config: FieldConfig<S, T>;
    readonly defaults: FieldDefaults<S, T>;
    with(config: FieldConfig<S, T>): FieldSpec<S, T>;
    /** Makes this field read-only.
     *
     * This is preferred to setting `readOnly` on `inputProps` as this method
     * sets additional props that you will probably want as well (e.g. `disabled`).
     *
     * @see IFieldSpec.readOnlyIf */
    readOnly(): FieldSpec<S, T>;
    /** Make this field editable (i.e. not read-only).
     *
     * Fields are editable by default, but this method may be
     * used to undo a `.readOnly()` or `.readOnlyIf()` modifier.
     *
     * @see IFieldSpec.readOnly */
    editable(): FieldSpec<S, T>;
    /** Makes this field read-only if the `condition` is true.
     * If the `condition` is false, the field
     * becomes editable if it was read-only.
     *
     * @see IFieldSpec.readOnly */
    readOnlyIf(condition: boolean): FieldSpec<S, T>;
}
export declare type FieldCategory = 'textual' | 'numeric' | 'enum' | 'binary';
export interface FieldDefaults<S, T> extends FieldConfig<S, T> {
    category?: FieldCategory;
    blankInput: S;
    isBlank?(input: S): boolean;
    parse(input: S): Result<T>;
    validate(value: T): Result<T>;
    acceptExternal?(data: unknown): S | undefined;
}
export declare class FieldSpec<S, T> implements IFieldSpec<S, T> {
    readonly config: FieldConfig<S, T>;
    readonly defaults: FieldDefaults<S, T>;
    constructor(config: FieldConfig<S, T>, defaults: FieldDefaults<S, T>);
    with(config: FieldConfig<S, T>): FieldSpec<S, T>;
    readOnly(): FieldSpec<S, T>;
    editable(): FieldSpec<S, T>;
    readOnlyIf(condition: boolean): FieldSpec<S, T>;
}
export declare function useField<S, T>(field: FieldSpec<S, T>, name: string): Field<S, T>;
export {};
