{"version":3,"file":"index.js","sources":["../src/core/Being.ts","../src/core/Result.tsx","../src/core/EnumOption.ts","../src/utils/utils.ts","../src/core/Field.tsx","../src/utils/useMountEffect.tsx","../src/core/useInputState.tsx","../node_modules/classnames/index.js","../src/core/Theme.tsx","../src/core/XFormLocale.tsx","../src/core/XFormContext.tsx","../src/core/FieldSpec.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/core/useFormState.tsx","../src/core/Submitter.tsx","../src/core/$Submitter.tsx","../src/core/Form.tsx","../src/core/$Form.tsx","../src/core/CustomField.tsx","../src/builtin/checkbox.tsx","../src/builtin/checklist.tsx","../src/builtin/date.tsx","../src/builtin/decimal.tsx","../src/builtin/number.tsx","../src/builtin/text.tsx","../src/builtin/password.tsx","../src/builtin/select.tsx","../src/builtin/radio.tsx","../src/builtin/textarea.tsx","../src/builtin/time.tsx","../src/core/optional.tsx","../src/builtin/button.tsx","../src/utils/Debug.tsx"],"sourcesContent":["import _ from 'lodash';\n\nexport interface Being {\n    is(x: any): boolean;\n}\n\nexport function isBeing(obj: unknown): obj is Being {\n    return _.isFunction((obj as any)?.is);\n}\n","import Immutable, { ValueObject } from 'immutable';\nimport _ from 'lodash';\nimport { isBeing } from './Being';\n\n/***\n *    ██████╗ ███████╗███████╗██╗   ██╗██╗  ████████╗\n *    ██╔══██╗██╔════╝██╔════╝██║   ██║██║  ╚══██╔══╝\n *    ██████╔╝█████╗  ███████╗██║   ██║██║     ██║\n *    ██╔══██╗██╔══╝  ╚════██║██║   ██║██║     ██║\n *    ██║  ██║███████╗███████║╚██████╔╝███████╗██║\n *    ╚═╝  ╚═╝╚══════╝╚══════╝ ╚═════╝ ╚══════╝╚═╝\n *\n */\n\n/** The return type for `parse` and `validate` functions.\n *\n * `Result` can store the following results after a field is parsed and/or\n * validated:\n * - a `Valid(value)`\n * - an `Invalid(message)` where `message` is the error message shown to the\n * user below the field.\n *\n * Note for immutable users: `Result` implements `ValueObject`.\n *\n * Note for functional programmers: the `Result` type is a chainable functor. */\nexport abstract class Result<T> implements ValueObject {\n    /** Use `.equals(...)` instead of `===` or `==` for equality by value.\n     *\n     * ```\n     * Result(42) === Result(42) // false\n     * Result(42) == Result(42) // false\n     * Result(42).equals(Result(42)) // true\n     * ``` */\n    abstract equals(other: any): boolean;\n\n    /** Used internally by the `immutable` package to optimize equality checks.\n     * */\n    abstract hashCode(): number;\n\n    /** Applies the given function to the value of a `Valid` result, returning\n     * another `Valid` result with the transformed value.\n     *\n     * If applied to an `Invalid` result it returns that same result unmodified.\n     *\n     * Examples:\n     * - `Valid(42).map(x => x + 1)  // Valid(43)`\n     * - `Invalid(\"Oops\").map(x => x + 1)  // Invalid(\"Oops\")`\n     * */\n    abstract map<U>(fn: (x: T) => U): Result<U>;\n\n    /** Applies the `fn` function to the value of a `Valid` result, returning\n     * the same result that `fn` returned.\n     *\n     * If applied to an `Invalid` result it returns that same result unmodified.\n     *\n     * Examples:\n     * - `Valid(42).chain(x => Invalid(x + '!'))  // Invalid(\"42!\")`\n     * - `Invalid(\"Oops\").chain(x => Invalid(x + '!')) // Invalid(\"Oops\")`\n     * */\n    abstract chain<U>(fn: (x: T) => Result<U>): Result<U>;\n\n    /** Gets the value assuming the result is `Valid`, or throws otherwise.\n     *\n     * You can pass an errorMessage to be shown\n     * if an `Invalid` result is unwrapped. */\n    abstract unwrap(errorMessage?: string): T;\n\n    /** Checks whether this result is a `Valid` result with the given value,\n     * using `Immutable.is` for the equality check.\n     *\n     * Examples:\n     * ```\n     * Valid(42).is(42) // true\n     * Valid(\"42\").is(42) // false\n     * Invalid(\"Nope\").is(42) // false\n     * ``` */\n    abstract is(value: T): boolean;\n\n    /** Checks whether this result is a `Valid` result whose value satisfies\n     * the given predicate.\n     *\n     * Examples:\n     * ```\n     * const over9000 = x => x > 9000;\n     * Valid(9999).is(over9000) // true\n     * Valid(42).is(over9000) // false\n     * Invalid('Whoops').is(over9000) // false\n     * ```\n     * */\n    abstract is(predicate: Predicate<T>): boolean;\n\n    /** Checks whether this result is an instance of the given result type.\n     *\n     * Examples:\n     * ```\n     * Valid(42).is(Valid) // true\n     * Valid(42).is(Invalid) // false\n     * Invalid('...').is(Valid) // false\n     * Invalid('...').is(Invalid) // true\n     * ``` */\n    abstract is(type: ResultType): boolean;\n}\n\nexport type Predicate<T> = (x: T) => boolean;\n\nexport type ResultType = typeof Valid | typeof Invalid;\n\nfunction isResultType(x: any): x is ResultType {\n    return x === Valid || x === Invalid;\n}\n\n/***\n *    ██╗   ██╗ █████╗ ██╗     ██╗██████╗\n *    ██║   ██║██╔══██╗██║     ██║██╔══██╗\n *    ██║   ██║███████║██║     ██║██║  ██║\n *    ╚██╗ ██╔╝██╔══██║██║     ██║██║  ██║\n *     ╚████╔╝ ██║  ██║███████╗██║██████╔╝\n *      ╚═══╝  ╚═╝  ╚═╝╚══════╝╚═╝╚═════╝\n *\n */\n\n/** @see Result */\nclass $Valid<T> extends Result<T> {\n    constructor(readonly value: T) {\n        super();\n    }\n\n    equals(other: any): boolean {\n        return other instanceof Valid && Immutable.is(this.value, other.value);\n    }\n\n    hashCode(): number {\n        return Immutable.hash(this.value);\n    }\n\n    map<U>(fn: (x: T) => U): Valid<U> {\n        return Valid(fn(this.value));\n    }\n\n    chain<U>(fn: (x: T) => Result<U>): Result<U> {\n        return fn(this.value);\n    }\n\n    unwrap(_errorMessage?: string): T {\n        return this.value;\n    }\n\n    is(arg: T | Predicate<T> | ResultType): boolean {\n        if (isResultType(arg)) {\n            return arg === Valid;\n        }\n\n        if (_.isFunction(arg)) {\n            return arg(this.value);\n        }\n\n        if (isBeing(this.value)) {\n            return this.value.is(arg);\n        }\n\n        return Immutable.is(this.value, arg);\n    }\n}\n\n/** @see Result */\nexport type Valid<T> = $Valid<T>;\n\n/** @see Result */\n// // eslint-disable-next-line @typescript-eslint/no-redeclare\nexport function Valid<T>(value: T): Valid<T> {\n    return new $Valid(value);\n}\n\n// make `Valid(...) instanceof Valid` to work\nValid.prototype = $Valid.prototype;\n\n/***\n *    ██╗███╗   ██╗██╗   ██╗ █████╗ ██╗     ██╗██████╗\n *    ██║████╗  ██║██║   ██║██╔══██╗██║     ██║██╔══██╗\n *    ██║██╔██╗ ██║██║   ██║███████║██║     ██║██║  ██║\n *    ██║██║╚██╗██║╚██╗ ██╔╝██╔══██║██║     ██║██║  ██║\n *    ██║██║ ╚████║ ╚████╔╝ ██║  ██║███████╗██║██████╔╝\n *    ╚═╝╚═╝  ╚═══╝  ╚═══╝  ╚═╝  ╚═╝╚══════╝╚═╝╚═════╝\n *\n */\n\n/** @see Result */\nclass $Invalid<T> extends Result<T> {\n    constructor(readonly message: string) {\n        super();\n    }\n\n    equals(other: any): boolean {\n        return other instanceof Invalid && this.message === other.message;\n    }\n\n    hashCode(): number {\n        return Immutable.hash(this.message);\n    }\n\n    map<U>(_fn: (x: T) => U): Invalid<U> {\n        return this.cast();\n    }\n\n    chain<U>(_fn: (x: T) => Result<U>): Result<U> {\n        return this.cast();\n    }\n\n    unwrap(errorMessage?: string): T {\n        throw new UnwrapError(\n            errorMessage ?? 'Attempted to unwrap an Invalid result',\n            this\n        );\n    }\n\n    is(arg: T | Predicate<T> | ResultType): boolean {\n        return arg === Invalid;\n    }\n\n    /** Casts this `Invalid<T>` instance to `Invalid<U>`. */\n    cast<U>(): Invalid<U> {\n        // `Invalid` results always store strings so this is safe\n        return (this as unknown) as Invalid<U>;\n    }\n}\n\n/** @see Result */\nexport type Invalid<T> = $Invalid<T>;\n\n/** @see Result */\n// // eslint-disable-next-line @typescript-eslint/no-redeclare\nexport function Invalid<T>(message: string): Invalid<T> {\n    return new $Invalid(message);\n}\n\n// make `Invalid(\"...\") instanceof Invalid` to work\nInvalid.prototype = $Invalid.prototype;\n\nexport class UnwrapError<T> extends Error {\n    constructor(message: string, readonly result: Invalid<T>) {\n        super(message);\n    }\n}\n","import { InputProps, LabelProps } from '../utils/htmlProps';\nimport Immutable, { ValueObject } from 'immutable';\nimport { Being } from './Being';\n\nexport interface EnumOption {\n    readonly value: string;\n    readonly label: string;\n}\n\nexport class Option implements EnumOption, ValueObject, Being {\n    readonly value: string;\n    readonly label: string;\n\n    constructor(option: EnumOption) {\n        this.value = option.value;\n        this.label = option.label;\n    }\n\n    toJSON(): string {\n        return this.value;\n    }\n\n    equals(other: any): boolean {\n        return (\n            other instanceof Option &&\n            Immutable.is(this.value, other.value) &&\n            Immutable.is(this.label, other.label)\n        );\n    }\n\n    hashCode(): number {\n        return Immutable.hash(this.value) ^ Immutable.hash(this.label);\n    }\n\n    is(s: string): boolean {\n        return this.value === s || this.label === s;\n    }\n}\n\nexport class OptionWithProps extends Option {\n    constructor(\n        readonly option: Option,\n        readonly inputProps: InputProps,\n        readonly labelProps: LabelProps\n    ) {\n        super(option);\n    }\n}\n","import React, { ReactElement } from 'react';\n\n/** Because we can't do `x instanceof ReactElement`. */\nexport function isReactElement(x: any): x is ReactElement {\n    return React.isValidElement(x);\n}\n\nexport function isEmptyOrWhitespace(input: string): boolean {\n    return input.trim().length === 0;\n}\n\nexport function removeExcessWhitespace(input: string): string {\n    return input.trim().replace(/  +/g, ' ');\n}\n\nconst single = \"'\";\nconst double = '\"';\n\nexport function quote(s: string, preferredQuote: string = double): string {\n    if (\n        [single, double].includes(preferredQuote) &&\n        s.includes(preferredQuote)\n    ) {\n        const alternativeQuote = preferredQuote === double ? single : double;\n\n        if (s.includes(alternativeQuote)) {\n            return (\n                preferredQuote +\n                s.replace(\n                    new RegExp(alternativeQuote, 'g'),\n                    '\\\\' + alternativeQuote\n                ) +\n                preferredQuote\n            );\n        }\n\n        return alternativeQuote + s + alternativeQuote;\n    }\n\n    return preferredQuote + s + preferredQuote;\n}\n\nexport function scrollToTop(): void {\n    window.scrollTo({\n        top: 0,\n        behavior: 'smooth',\n    });\n}\n","import * as React from 'react';\nimport { ChangeEvent, FocusEvent, ReactElement, RefObject } from 'react';\nimport {\n    FieldCategory,\n    FieldConfig,\n    FieldDefaults,\n    Options,\n} from './FieldSpec';\nimport { InputProps, LabelProps, TextAreaProps } from '../utils/htmlProps';\nimport { InputState } from './useInputState';\nimport { Invalid, Predicate, Result, ResultType, Valid } from './Result';\nimport Immutable from 'immutable';\nimport deepExtend from 'deep-extend';\nimport { Theme } from './Theme';\nimport { EnumOption, Option, OptionWithProps } from './EnumOption';\nimport {\n    isReactElement,\n    quote,\n    removeExcessWhitespace,\n    scrollToTop,\n} from '../utils/utils';\nimport { Form, FormFields } from './Form';\nimport _ from 'lodash';\nimport { XFormLocale } from './XFormLocale';\n\nexport const setForm = Symbol('setForm');\nexport const describe = Symbol('describe');\n\ninterface IField<S, T> {\n    readonly locale: XFormLocale;\n    readonly defaults: FieldDefaults<S, T>;\n    readonly config: FieldConfig<S, T>;\n    readonly name: string;\n    readonly input: InputState<S>;\n    readonly containerRef: RefObject<HTMLDivElement>;\n    readonly inputRef: RefObject<HTMLInputElement>;\n    readonly textAreaRef: RefObject<HTMLTextAreaElement>;\n    readonly theme: Theme;\n\n    readonly form: Form<any>;\n\n    /** @internal */\n    [setForm]<T>(form: Form<T>): void;\n\n    readonly category?: FieldCategory;\n    readonly nonZero: boolean;\n    readonly allowNegative: boolean;\n\n    /** True if the field is optional, i.e was wrapped in an `optional`.\n     * By default all built-in builtin are required. */\n    readonly isOptional: boolean;\n\n    readonly subFields: FormFields;\n\n    readonly result: Result<T>;\n\n    /** True if the field can be submitted with the current input, i.e. the user\n     * input is in the requested format and the corresponding value passes all\n     * validations. */\n    readonly isValid: boolean;\n\n    is(value: T): boolean;\n\n    is(predicate: Predicate<T>): boolean;\n\n    is(type: ResultType): boolean;\n\n    readonly label?: string | ReactElement;\n    readonly inputProps: InputProps;\n    readonly textAreaProps: TextAreaProps;\n    readonly options: OptionWithProps[];\n\n    [describe](): string;\n\n    preprocess(input: S): S;\n\n    isBlank(input: S): boolean;\n\n    parse(input: S): Result<T>;\n\n    validate(value: T): Result<T>;\n\n    optionInputProps(option: Option): InputProps;\n\n    shouldBeShown: boolean;\n\n    render(): ReactElement | null;\n\n    focus: HTMLInputElement['focus'];\n\n    isFocused: boolean;\n\n    fillWith(data: any): void;\n\n    reset(): void;\n}\n\nexport class Field<S, T> implements IField<S, T> {\n    constructor(\n        readonly locale: XFormLocale,\n        readonly defaults: FieldDefaults<S, T>,\n        readonly config: FieldConfig<S, T>,\n        readonly name: string,\n        readonly input: InputState<S>,\n        readonly containerRef: RefObject<HTMLDivElement>,\n        readonly inputRef: RefObject<HTMLInputElement>,\n        readonly textAreaRef: RefObject<HTMLTextAreaElement>,\n        readonly theme: Theme,\n        readonly subFields: FormFields\n    ) {\n        _.forEach(subFields, (subField) => {\n            subField.superField = this;\n        });\n    }\n\n    private _form: Form<any> | undefined;\n\n    get form(): Form<any> {\n        if (this._form === undefined) {\n            throw new Error(\n                `Tried to access parent form before initialization`\n            );\n        }\n\n        return this._form;\n    }\n\n    [setForm]<T>(form: Form<T>): void {\n        this._form = form as any;\n        _.forEach(this.subFields, (subField) => {\n            subField[setForm](form);\n        });\n    }\n\n    /** @internal */\n    superField?: Field<any, any>;\n\n    private readonly defaultOptions: Options = [];\n\n    private defaultPreprocess(input: S): S {\n        return input;\n    }\n\n    private defaultIsBlank(input: S): boolean {\n        return Immutable.is(input, this.defaults.blankInput);\n    }\n\n    private readonly defaultBlankResult = Invalid<T>(\n        this.locale.fieldIsRequired\n    );\n\n    private readonly defaultBlankOption = this.locale.selectAnOption;\n\n    private defaultIsFocused(): boolean {\n        return this.input.isFocused;\n    }\n\n    // noinspection JSMethodCanBeStatic\n    private defaultShowRule(): boolean {\n        return true;\n    }\n\n    private readonly defaultMethods = {\n        options: this.defaultOptions,\n        preprocess: this.defaultPreprocess,\n        isBlank: this.defaultIsBlank,\n        blankResult: this.defaultBlankResult,\n        blankOption: this.defaultBlankOption,\n        isFocused: this.defaultIsFocused,\n        showRule: this.defaultShowRule,\n    };\n\n    private readonly methods = _.merge(\n        {},\n        this.defaultMethods,\n        this.defaults,\n        this.config\n    );\n\n    readonly label = this.methods.label;\n    readonly preprocess = this.methods.preprocess.bind(this);\n    readonly isBlank = this.methods.isBlank.bind(this);\n    readonly blankResult = this.methods.blankResult;\n    readonly blankOption = this.methods.blankOption;\n    readonly parse = this.methods.parse.bind(this);\n    readonly validate = this.methods.validate.bind(this);\n    readonly category = this.methods.category;\n    readonly nonZero = this.methods.nonZero ?? false;\n    readonly allowNegative = this.methods.allowNegative ?? false;\n    private readonly getIsFocused = this.methods.isFocused.bind(this);\n    private readonly showRule = this.methods.showRule.bind(this);\n\n    readonly isOptional = this.blankResult instanceof Valid;\n\n    readonly inputProps = this.computeInputProps();\n\n    private computeInputProps(): InputProps {\n        const field = this;\n        const { config, defaults, name, input } = field;\n\n        const defaultInputProps: Partial<InputProps> = {\n            id: name,\n            name,\n        };\n        if (typeof input.value === 'boolean') {\n            defaultInputProps.checked = input.value;\n        } else {\n            defaultInputProps.value = input.value as any;\n        }\n\n        const eventHandlers: Partial<InputProps> = {\n            onChange(event) {\n                field.defaultOnChange(event);\n                defaults.inputProps?.onChange?.bind(field)?.(event);\n                config.inputProps?.onChange?.bind(field)?.(event);\n            },\n\n            onFocus(event) {\n                field.defaultOnFocus(event);\n                defaults.inputProps?.onFocus?.bind(field)?.(event);\n                config.inputProps?.onFocus?.bind(field)?.(event);\n            },\n\n            onBlur(event) {\n                field.defaultOnBlur(event);\n                defaults.inputProps?.onBlur?.bind(field)?.(event);\n                config.inputProps?.onBlur?.bind(field)?.(event);\n            },\n        };\n\n        return deepExtend(\n            defaultInputProps,\n            _.merge({}, defaults.inputProps, {\n                placeholder: defaults.placeholder,\n            }),\n            _.merge({}, config.inputProps, {\n                placeholder: config.placeholder,\n            }),\n            eventHandlers\n        );\n    }\n\n    private defaultOnChange(event: ChangeEvent<HTMLInputElement>) {\n        if (typeof this.input.value === 'boolean') {\n            this.input.setValue(event.target.checked as any);\n        }\n\n        if (typeof event.target.value !== typeof this.input.value) {\n            return;\n        }\n\n        this.input.setValue(event.target.value as any);\n    }\n\n    private defaultOnFocus(_event: FocusEvent<HTMLDivElement>) {\n        this.input.setIsFocused(true);\n    }\n\n    private defaultOnBlur(_event: FocusEvent<HTMLInputElement>) {\n        this.input.setIsFocused(false);\n        this.input.setHasBeenBlurred(true);\n    }\n\n    readonly textAreaProps = this.inputProps as any;\n\n    private _result?: Result<T>;\n\n    get result(): Result<T> {\n        if (this._result == null) {\n            this._result = this.computeResult();\n        }\n        return this._result;\n    }\n\n    private computeResult(): Result<T> {\n        const {\n            preprocess,\n            isBlank,\n            blankResult,\n            parse,\n            input,\n            validate,\n        } = this;\n\n        const input_ = preprocess(input.value);\n        if (isBlank(input_)) {\n            return blankResult;\n        }\n        return parse(input_).chain(validate);\n    }\n\n    get isValid(): boolean {\n        return this.is(Valid);\n    }\n\n    /** Checks whether this field is a valid field with the given value,\n     * using `Immutable.is` for the equality check.\n     *\n     * Example\n     * ```\n     * const form = useForm($Form({\n     *     builtin: {\n     *         maritalStatus: $Select('Marital status').with({\n     *             options: ['Single', 'Married', ...]\n     *         }),\n     *         ...\n     *     },\n     *     ...\n     * }));\n     * const { maritalStatus } = form.builtin;\n     * maritalStatus.is('Married')\n     * ```\n     * */\n    is(value: T): boolean;\n\n    /** Checks whether this field is a valid field whose value satisfies\n     * the given predicate.\n     *\n     * Example:\n     * ```\n     * const { income } = form.builtin;\n     * const over9000 = x => x > 9000;\n     * income.is(over900)\n     * ``` */\n    is(predicate: Predicate<T>): boolean;\n\n    /** Checks whether this field is an instance of the given result type.\n     *\n     * Examples:\n     * ```\n     * field.is(Valid)\n     * field.is(Invalid)\n     * ``` */\n    is(type: ResultType): boolean;\n\n    is(arg: T | Predicate<T> | ResultType): boolean {\n        return this.result.is(arg as any);\n    }\n\n    static getValueAssumingItIsValid<T>(field: Field<any, T>): T {\n        return field.result.unwrap(\n            `Couldn't get the value of the ${field[\n                describe\n            ]()} because it's invalid`\n        );\n    }\n\n    [describe](): string {\n        const { label, name } = this;\n        const tilde = '`';\n\n        if (\n            label == null ||\n            isReactElement(label) ||\n            removeExcessWhitespace(label) === ''\n        ) {\n            return `field at ${quote(name, tilde)}`;\n        }\n\n        return `field ${quote(label)} (${quote(name, tilde)})`;\n    }\n\n    optionInputProps(option: EnumOption): InputProps {\n        return {\n            ...this.defaultOptionInputProps(option),\n            ...this.defaults.optionInputProps?.call?.(this, option),\n            ...this.config.optionInputProps?.call?.(this, option),\n        };\n    }\n\n    readonly options = this.input.options.map((option) => {\n        const inputProps = this.optionInputProps(option);\n\n        const labelProps: LabelProps = {\n            htmlFor: inputProps.id,\n        };\n\n        return new OptionWithProps(option, inputProps, labelProps);\n    });\n\n    private defaultOptionInputProps(option: EnumOption): InputProps {\n        return {\n            ...this.inputProps,\n            id: `${this.name}_${option.value}`,\n            checked: (this.input.value as any) === option.value,\n            value: option.value,\n        };\n    }\n\n    get shouldBeShown(): boolean {\n        return this.showRule(this.form.fields);\n    }\n\n    render(): ReactElement | null {\n        if (!this.shouldBeShown) {\n            return null;\n        }\n\n        const { Field } = this.theme;\n        return <Field field={this} />;\n    }\n\n    focus(options?: FocusOptions): void {\n        const element = this.inputRef.current ?? this.textAreaRef.current;\n\n        if (element == null) {\n            console.error(\n                `I tried to focus the ${this[\n                    describe\n                ]()} but it doesn't have an inputRef or textAreaRef`\n            );\n            return;\n        }\n\n        element.focus(options);\n    }\n\n    get isFocused(): boolean {\n        return this.getIsFocused();\n    }\n\n    fillWith(data: any): void {\n        const input = this.acceptExternal(data);\n\n        if (input !== undefined) {\n            this.input.setValue(input);\n        }\n    }\n\n    private acceptExternal(data: any): S | undefined {\n        if (data === undefined) {\n            return undefined;\n        }\n\n        if (data === null) {\n            return this.defaults.blankInput;\n        }\n\n        const input = this.methods.acceptExternal?.(data);\n\n        if (input !== undefined) {\n            return input;\n        }\n\n        if (data.constructor === (this.input.value as any).constructor) {\n            return data;\n        }\n    }\n\n    reset(): void {\n        this.input.setValue(this.input.initialValue);\n        this.input.setHasBeenBlurred(false);\n        _.forEach(this.subFields, (subField) => {\n            subField.reset();\n        });\n    }\n}\n\nexport function scrollToField<S, T>(field: Field<S, T>): boolean {\n    if (field.containerRef.current == null) {\n        scrollToTop();\n        console.error(\n            `I tried to scroll to the ${field[describe]()}, ` +\n                `but it doesn't have a containerRef to scroll to`\n        );\n        return false;\n    }\n\n    field.containerRef.current.scrollIntoView({\n        behavior: 'smooth',\n    });\n    return true;\n}\n","import { EffectCallback, useEffect } from 'react';\n\nexport function useMountEffect(effect: EffectCallback): void {\n    // eslint-disable-next-line\n    useEffect(effect, []);\n}\n","import { Dispatch, SetStateAction, useState } from 'react';\nimport { Option } from './EnumOption';\nimport { useMountEffect } from '../utils/useMountEffect';\nimport _ from 'lodash/fp';\nimport { AsyncOptions, FieldOption, Options } from './FieldSpec';\n\nexport interface InputState<S> {\n    readonly value: S;\n    readonly setValue: Dispatch<SetStateAction<S>>;\n\n    readonly isFocused: boolean;\n    readonly setIsFocused: Dispatch<SetStateAction<boolean>>;\n\n    readonly hasBeenBlurred: boolean;\n    readonly setHasBeenBlurred: Dispatch<SetStateAction<boolean>>;\n\n    readonly isLoading: boolean;\n    readonly error: Error | null;\n    readonly options: Option[];\n\n    readonly initialValue: S;\n}\n\nexport function useInputState<S>(\n    initialValue: S,\n    optionsObject: Options\n): InputState<S> {\n    const [value, setValue] = useState(initialValue);\n    const [isFocused, setIsFocused] = useState(false);\n    const [hasBeenBlurred, setHasBeenBlurred] = useState(false);\n\n    const [isLoading, setIsLoading] = useState(isAsync(optionsObject));\n    const [error, setError] = useState<Error | null>(null);\n    const [options, setOptions] = useState(\n        isAsync(optionsObject) ? [] : optionsObject.map(parseOption)\n    );\n\n    useMountEffect(() => {\n        if (isAsync(optionsObject)) {\n            optionsObject()\n                .then(_.map(parseOption))\n                .then(setOptions)\n                .catch(setError)\n                .finally(() => setIsLoading(false));\n        }\n    });\n\n    return {\n        value,\n        setValue,\n        isFocused,\n        setIsFocused,\n        hasBeenBlurred,\n        setHasBeenBlurred,\n        isLoading,\n        error,\n        options,\n        initialValue,\n    };\n}\n\nfunction isAsync(options: Options): options is AsyncOptions {\n    return _.isFunction(options);\n}\n\nfunction parseOption(option: FieldOption): Option {\n    if (typeof option === 'string') {\n        return new Option({ value: option, label: option });\n    }\n\n    return new Option(option);\n}\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import React, { PropsWithChildren, ReactElement } from 'react';\nimport { Invalid } from './Result';\nimport { Field } from './Field';\nimport classNames from 'classnames';\nimport _ from 'lodash';\n\nexport interface Theme {\n    readonly Field: ThemeComponent;\n    readonly FieldContainer: ThemeComponentWithChildren;\n    readonly Label: ThemeComponent;\n    readonly Optional: ThemeComponent;\n    readonly Input: ThemeComponent;\n    readonly Message: ThemeComponent;\n    readonly Error: ThemeComponentWithChildren;\n}\n\ntype ThemeComponent = <S, T>(props: ThemeProps<S, T>) => ReactElement | null;\n\ntype ThemeComponentWithChildren = <S, T>(\n    props: PropsWithChildren<ThemeProps<S, T>>\n) => ReactElement | null;\n\ntype ThemeProps<S, T> = {\n    field: Field<S, T>;\n    className?: string;\n};\n\nexport const defaultTheme: Theme = {\n    Field({ field, className }) {\n        const { FieldContainer, Label, Input, Message } = field.theme;\n        return (\n            <FieldContainer field={field} className={className}>\n                <Label field={field} />\n                <Input field={field} />\n                <Message field={field} />\n            </FieldContainer>\n        );\n    },\n\n    FieldContainer({ field, className, children }) {\n        return (\n            <div\n                className={className}\n                style={{ marginBottom: '1em' }}\n                ref={field.containerRef}\n            >\n                {children}\n            </div>\n        );\n    },\n\n    Label({ field, className }) {\n        const { label, inputProps, theme } = field;\n        const { Optional } = theme;\n\n        if (label != null) {\n            return (\n                <label htmlFor={inputProps.id} className={className}>\n                    {label}\n                    <Optional field={field} />\n                </label>\n            );\n        }\n\n        return null;\n    },\n\n    Optional({ field, className }) {\n        if (field.isOptional) {\n            return (\n                <em className={className} style={{ color: '#585858' }}>\n                    {' '}\n                    ({field.locale.optional})\n                </em>\n            );\n        }\n\n        return null;\n    },\n\n    Input({ field, className }) {\n        return (\n            <input\n                {...field.inputProps}\n                className={classNames(field.inputProps.className, className)}\n                ref={field.inputRef}\n            />\n        );\n    },\n\n    Message({ field, className }) {\n        const { result, input, form, theme } = field;\n        const { Error } = theme;\n\n        if (\n            result instanceof Invalid &&\n            (input.hasBeenBlurred || form.hasBeenSubmitted)\n        ) {\n            return (\n                <Error field={field} className={className}>\n                    {result.message}\n                </Error>\n            );\n        }\n\n        return null;\n    },\n\n    Error({ className, children }) {\n        return (\n            <small\n                className={className}\n                style={{ color: '#b60000', fontWeight: 600 }}\n            >\n                {children}\n            </small>\n        );\n    },\n};\n\nexport function injectClassNames(\n    theme: Theme,\n    injectedClassNames: Partial<Record<keyof Theme, string>>\n): Theme {\n    return _.mapValues(theme, (OriginalComponent: any, componentName) => {\n        return function ComponentWithInjectedClassName<S, T>(\n            props: PropsWithChildren<ThemeProps<S, T>>\n        ) {\n            return (\n                <OriginalComponent\n                    field={props.field}\n                    className={classNames(\n                        injectedClassNames[componentName],\n                        props.className\n                    )}\n                >\n                    {props.children}\n                </OriginalComponent>\n            );\n        };\n    });\n}\n","import Decimal from 'decimal.js';\n\nexport interface XFormLocale {\n    selectAnOption: string;\n    optional: string;\n    fieldIsRequired: string;\n    invalidNumber: string;\n    mustBeInt: string;\n    tooManyDecimals(maxDecimals: number): string;\n    negative: string;\n    tooSmall(min: Decimal): string;\n    tooBig(max: Decimal): string;\n    cantBeZero: string;\n    invalidDate: string;\n    invalidTime: string;\n    loading: string;\n}\n\nexport const english: XFormLocale = {\n    selectAnOption: '--- Select an option ---',\n    optional: 'Optional',\n    fieldIsRequired: 'Required field',\n    invalidNumber: 'Invalid number',\n    mustBeInt: 'Must be an integer number',\n    tooManyDecimals: (maxDecimals) =>\n        `No more than ${maxDecimals} decimals allowed`,\n    negative: \"Can't be a negative number\",\n    tooSmall: (min) => `Must be at least ${min}`,\n    tooBig: (max) => `Must be at most ${max}`,\n    cantBeZero: \"Can't be zero\",\n    invalidDate: 'Invalid date',\n    invalidTime: 'Invalid time',\n    loading: 'Loading...',\n};\n\nexport const spanish: XFormLocale = {\n    selectAnOption: '--- Seleccione una opción ---',\n    optional: 'Opcional',\n    fieldIsRequired: 'Campo requerido',\n    invalidNumber: 'Número inválido',\n    mustBeInt: 'Debe ser un número entero',\n    tooManyDecimals: (maxDecimals) =>\n        `No se permite más de ${maxDecimals} decimales`,\n    negative: 'No puede ser negativo',\n    tooSmall: (min) => `Debe ser al menos ${min}`,\n    tooBig: (max) => `Debe ser a lo más ${max}`,\n    cantBeZero: 'No puede ser 0',\n    invalidDate: 'Fecha inválida',\n    invalidTime: 'Hora inválida',\n    loading: 'Cargando...',\n};\n","import { english, XFormLocale } from './XFormLocale';\nimport { createContext } from 'react';\n\nexport interface IXFormContext {\n    locale: XFormLocale;\n}\n\nexport const XFormContext = createContext<IXFormContext>({ locale: english });\n","import _ from 'lodash';\nimport { ReactElement, useContext, useMemo, useRef } from 'react';\nimport { InputProps } from '../utils/htmlProps';\nimport { Field } from './Field';\nimport { useInputState } from './useInputState';\nimport { Result } from './Result';\nimport { defaultTheme, injectClassNames, Theme } from './Theme';\nimport { EnumOption } from './EnumOption';\nimport { XFormContext } from './XFormContext';\nimport { FormFields } from './Form';\n\nexport interface FieldConfig<S, T> {\n    readonly label?: string | ReactElement;\n    readonly inputProps?: InputProps;\n    readonly options?: Options;\n\n    /** For numeric builtin, `true` means zero\n     * is not a valid value for this field. */\n    readonly nonZero?: boolean;\n\n    /** For numeric builtin, `true` if negative numbers are valid\n     * for this field. By default negative numbers are not valid. */\n    readonly allowNegative?: boolean;\n\n    optionInputProps?(option: EnumOption): InputProps;\n\n    preprocess?(input: S): S;\n\n    /** Pass a string to change the '--- Select an option ---' label of a select,\n     * or pass either null or false to remove that option.\n     *\n     * By default locale.selectAnOption is used. */\n    readonly blankOption?: string | null | false;\n\n    readonly blankResult?: Result<T>;\n\n    readonly placeholder?: string;\n\n    readonly render?: Partial<Theme>;\n\n    readonly classNames?: Partial<Record<keyof Theme, string>>;\n\n    readonly initialInput?: S;\n\n    /** @internal\n     * The rule passed to `showIf` */\n    showRule?(fields: FormFields): boolean;\n}\n\nexport type FieldOption = EnumOption | string;\nexport type Options = FieldOption[] | AsyncOptions;\nexport type AsyncOptions = () => Promise<FieldOption[]>;\n\ninterface IFieldSpec<S, T> {\n    readonly config: FieldConfig<S, T>;\n    readonly defaults: FieldDefaults<S, T>;\n\n    with(config: FieldConfig<S, T>): FieldSpec<S, T>;\n\n    /** Makes this field read-only.\n     *\n     * This is preferred to setting `readOnly` on `inputProps` as this method\n     * sets additional props that you will probably want as well (e.g. `disabled`).\n     *\n     * @see IFieldSpec.readOnlyIf */\n    readOnly(): FieldSpec<S, T>;\n\n    /** Make this field editable (i.e. not read-only).\n     *\n     * Fields are editable by default, but this method may be\n     * used to undo a `.readOnly()` or `.readOnlyIf()` modifier.\n     *\n     * @see IFieldSpec.readOnly */\n    editable(): FieldSpec<S, T>;\n\n    /** Makes this field read-only if the `condition` is true.\n     * If the `condition` is false, the field\n     * becomes editable if it was read-only.\n     *\n     * @see IFieldSpec.readOnly */\n    readOnlyIf(condition: boolean): FieldSpec<S, T>;\n\n    showIf(rule: (fields: FormFields) => boolean): FieldSpec<S, T>;\n}\n\nexport type FieldCategory = 'textual' | 'numeric' | 'enum' | 'binary';\n\nexport interface FieldDefaults<S, T> extends FieldConfig<S, T> {\n    category?: FieldCategory;\n\n    blankInput: S;\n\n    isBlank?(input: S): boolean;\n\n    parse(input: S): Result<T>;\n\n    validate(value: T): Result<T>;\n\n    acceptExternal?(data: unknown): S | undefined;\n\n    isFocused?(): boolean;\n\n    /** @internal */\n    subFields?: Record<string, FieldSpec<any, any>>;\n}\n\nexport class FieldSpec<S, T> implements IFieldSpec<S, T> {\n    constructor(\n        readonly config: FieldConfig<S, T>,\n        readonly defaults: FieldDefaults<S, T>\n    ) {}\n\n    with(config: FieldConfig<S, T>): FieldSpec<S, T> {\n        return new FieldSpec(_.merge({}, this.config, config), this.defaults);\n    }\n\n    readOnly(): FieldSpec<S, T> {\n        return this.readOnlyIf(true);\n    }\n\n    editable(): FieldSpec<S, T> {\n        return this.readOnlyIf(false);\n    }\n\n    readOnlyIf(condition: boolean): FieldSpec<S, T> {\n        return this.with({\n            inputProps: {\n                readOnly: condition,\n                disabled: condition,\n                'aria-readonly': condition,\n                'aria-disabled': condition,\n            },\n        });\n    }\n\n    showIf(rule: (fields: FormFields) => boolean): FieldSpec<S, T> {\n        return this.with({\n            showRule: rule,\n        });\n    }\n}\n\nexport function useField<S, T>(\n    field: FieldSpec<S, T>,\n    name: string\n): Field<S, T> {\n    const { locale } = useContext(XFormContext);\n    const optionsMethod = field.config.options ?? field.defaults.options ?? [];\n    const input = useInputState(\n        field.config.initialInput ??\n            field.defaults.initialInput ??\n            field.defaults.blankInput,\n        optionsMethod\n    );\n    const containerRef = useRef(null);\n    const inputRef = useRef(null);\n    const textAreaRef = useRef(null);\n\n    /* Memoize any inline components defined by the user to avoid bugs where the\n     * input loses focus due to React rendering a different component each time. */\n    const theme = useMemo(() => {\n        const theme = _.merge(\n            {},\n            defaultTheme,\n            field.defaults.render,\n            field.config.render\n        );\n        const injectedClassNames = _.merge(\n            {},\n            field.defaults.classNames,\n            field.config.classNames\n        );\n        return injectClassNames(theme, injectedClassNames);\n    }, []);\n\n    const subFields = _.mapValues(field.defaults.subFields ?? {}, useField);\n\n    return new Field(\n        locale,\n        field.defaults,\n        field.config,\n        name,\n        input,\n        containerRef,\n        inputRef,\n        textAreaRef,\n        theme,\n        subFields\n    );\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Dispatch, SetStateAction, useState } from 'react';\n\nexport const setIsSubmitting = Symbol('setIsSubmitting');\nexport const setHasBeenSubmitted = Symbol('setHasBeenSubmitted');\nexport const setSubmitError = Symbol('setSubmitError');\n\nexport interface FormState {\n    readonly isSubmitting: boolean;\n    readonly [setIsSubmitting]: Dispatch<SetStateAction<boolean>>;\n\n    readonly hasBeenSubmitted: boolean;\n    readonly [setHasBeenSubmitted]: Dispatch<SetStateAction<boolean>>;\n\n    readonly submitError: Error | null;\n    readonly [setSubmitError]: Dispatch<SetStateAction<Error | null>>;\n}\n\nexport function useFormState(): FormState {\n    const [isSubmitting, setIsSubmitting_] = useState(false);\n    const [hasBeenSubmitted, setHasBeenSubmitted_] = useState(false);\n    const [submitError, setSubmitError_] = useState<Error | null>(null);\n\n    return {\n        isSubmitting,\n        [setIsSubmitting]: setIsSubmitting_,\n\n        hasBeenSubmitted,\n        [setHasBeenSubmitted]: setHasBeenSubmitted_,\n\n        submitError,\n        [setSubmitError]: setSubmitError_,\n    };\n}\n","import { ButtonProps } from '../utils/htmlProps';\nimport React, { ReactElement } from 'react';\nimport { SubmitConfig } from './$Submitter';\nimport { Form } from './Form';\nimport {\n    setHasBeenSubmitted,\n    setIsSubmitting,\n    setSubmitError,\n} from './useFormState';\nimport { scrollToTop } from '../utils/utils';\nimport _ from 'lodash';\nimport { scrollToField, setForm } from './Field';\n\ninterface ISubmitter<T> {\n    readonly config: SubmitConfig<T>;\n    readonly buttonProps: ButtonProps;\n\n    render(): ReactElement;\n\n    submit(form: Form<T>): Promise<void>;\n}\n\nexport class Submitter<T> implements ISubmitter<T> {\n    constructor(readonly config: SubmitConfig<T>) {}\n\n    private _form: Form<T> | undefined;\n\n    get form(): Form<T> {\n        if (this._form === undefined) {\n            throw new Error(\n                `Tried to access parent form before initialization`\n            );\n        }\n\n        return this._form;\n    }\n\n    [setForm](form: Form<T>): void {\n        this._form = form;\n    }\n\n    private _buttonProps?: ButtonProps;\n\n    get buttonProps(): ButtonProps {\n        if (this._buttonProps == null) {\n            this._buttonProps = this.computeButtonProps();\n        }\n        return this._buttonProps;\n    }\n\n    private computeButtonProps(): ButtonProps {\n        const { config, form } = this;\n        return {\n            type: 'submit',\n            disabled: config.onInvalid === 'disable' && !form.isValid,\n            ...this.config.buttonProps,\n        };\n    }\n\n    render(): ReactElement {\n        return render(this);\n    }\n\n    async submit(form: Form<T>): Promise<void> {\n        form.state[setHasBeenSubmitted](true);\n\n        if (!form.isValid) {\n            return this.onInvalid(form);\n        }\n\n        const values = form.getValuesAssumingTheyAreValid();\n\n        form.state[setSubmitError](null);\n        form.state[setIsSubmitting](true);\n        try {\n            await this.onValid(values);\n        } catch (err) {\n            form.state[setSubmitError](err);\n            this.onError(err, form);\n        } finally {\n            form.state[setIsSubmitting](false);\n        }\n    }\n\n    private readonly onValid = this.config.onValid;\n\n    private onInvalid(form: Form<T>): void {\n        if (this.config.onInvalid === 'disable') {\n            return;\n        }\n\n        if (_.isFunction(this.config.onInvalid)) {\n            this.config.onInvalid(form);\n            return;\n        }\n\n        return Submitter.defaultOnInvalid(form);\n    }\n\n    private static defaultOnInvalid<T>(form: Form<T>): void {\n        const firstInvalidField = _.find(\n            form.fields,\n            (field) => !field.isValid\n        );\n\n        if (firstInvalidField == null) {\n            scrollToTop();\n            return;\n        }\n\n        firstInvalidField.focus({\n            preventScroll: scrollToField(firstInvalidField),\n        });\n    }\n\n    private onError = this.config.onError ?? Submitter.defaultOnError;\n\n    private static defaultOnError(err: Error /*, form: Form */): void {\n        throw err;\n    }\n}\n\nfunction render<T>({ config, buttonProps }: Submitter<T>): ReactElement {\n    return <button {...buttonProps}>{config.label}</button>;\n}\n","import _ from 'lodash';\nimport { ButtonSpec } from '../builtin/button';\nimport { ReactElement } from 'react';\nimport { ButtonProps } from '../utils/htmlProps';\nimport { Submitter } from './Submitter';\nimport { Form } from './Form';\n\nexport interface SubmitConfig<T = any> {\n    readonly label?: string | ReactElement;\n    readonly onValid: OnValid<T>;\n    readonly onInvalid?: OnInvalid<T> | 'disable';\n    readonly onError?: OnError<T>;\n    readonly buttonProps?: ButtonProps;\n}\n\nexport type OnValid<T> = (values: T) => Promise<void>;\nexport type OnInvalid<T> = (form: Form<T>) => void;\nexport type OnError<T> = (err: Error, form: Form<T>) => void;\n\ninterface I$Submitter<T> {\n    readonly config: SubmitConfig<T>;\n\n    with(config: Partial<SubmitConfig<T>>): ButtonSpec<T>;\n}\n\nexport class $Submitter<T = any> implements I$Submitter<T> {\n    constructor(readonly config: SubmitConfig<T>) {}\n\n    with(config: Partial<SubmitConfig<T>>): $Submitter<T> {\n        return new $Submitter(_.merge({}, this.config, config));\n    }\n}\n\nexport function useSubmitter<T>(submitter: $Submitter<T>): Submitter<T> {\n    return new Submitter(submitter.config);\n}\n","import React, { ReactElement } from 'react';\nimport { FormConfig } from './$Form';\nimport { Field, setForm } from './Field';\nimport { Submitter } from './Submitter';\nimport _ from 'lodash';\nimport { FormProps } from '../utils/htmlProps';\nimport { FormState, setHasBeenSubmitted, setSubmitError } from './useFormState';\nimport autoBind from 'auto-bind';\nimport { Fields } from '../utils/types';\n\ninterface IForm<T> {\n    readonly config: FormConfig<T>;\n    readonly fields: Fields<T>;\n    readonly submitter: Submitter<T>;\n    readonly state: FormState;\n    readonly hasBeenSubmitted: boolean;\n    readonly props: FormProps;\n    readonly shownFields: Partial<Fields<T>>;\n    readonly isValid: boolean;\n\n    fillWith(data: Record<string, unknown>): void;\n\n    render(): ReactElement;\n\n    renderFields(): ReactElement;\n\n    renderSubmit(): ReactElement;\n\n    submit(): Promise<void>;\n\n    getValuesAssumingTheyAreValid(): T;\n\n    reset(): void;\n}\n\nexport type FormFields = Record<string, Field<any, any>>;\n\n// noinspection JSUnusedGlobalSymbols\nexport type FormValues = {\n    [p: string]: any;\n};\n\nexport class Form<T = any> implements IForm<T> {\n    constructor(\n        readonly config: FormConfig<T>,\n        readonly fields: Fields<T>,\n        readonly submitter: Submitter<T>,\n        readonly state: FormState\n    ) {\n        _.forEach(fields, (field) => field[setForm](this));\n        submitter[setForm](this);\n\n        autoBind(this);\n    }\n\n    readonly hasBeenSubmitted = this.state.hasBeenSubmitted;\n\n    readonly props = Form.propsFor(this);\n\n    private static propsFor<T>(form: Form<T>): FormProps {\n        return {\n            onSubmit(event) {\n                event.preventDefault();\n                form.submit().then();\n            },\n\n            ...form.config.props,\n        };\n    }\n\n    get shownFields(): Partial<Fields<T>> {\n        return this.lazyShownFields();\n    }\n\n    private lazyShownFields = lazy<Partial<Fields<T>>>(() => {\n        return _.pickBy(this.fields, 'shouldBeShown');\n    });\n\n    get isValid(): boolean {\n        return this.lazyIsValid();\n    }\n\n    private lazyIsValid = lazy<boolean>(() => {\n        return _.every(this.shownFields, 'isValid');\n    });\n\n    fillWith(data: Record<string, unknown>): void {\n        _.forEach(data, (value, key) => {\n            this.fields[key]?.fillWith(value);\n        });\n    }\n\n    render(): ReactElement {\n        return (\n            <form {...this.props}>\n                {this.renderFields()}\n                {this.renderSubmit()}\n            </form>\n        );\n    }\n\n    renderFields(): ReactElement {\n        return (\n            <React.Fragment>\n                {_.map(this.fields, (field) => (\n                    <React.Fragment key={field.name}>\n                        {field.render()}\n                    </React.Fragment>\n                ))}\n            </React.Fragment>\n        );\n    }\n\n    renderSubmit(): ReactElement {\n        return this.submitter.render();\n    }\n\n    async submit(): Promise<void> {\n        return this.submitter.submit(this);\n    }\n\n    getValuesAssumingTheyAreValid(): T {\n        return _.mapValues(\n            this.shownFields,\n            Field.getValueAssumingItIsValid\n        ) as any;\n    }\n\n    reset(): void {\n        _.forEach(this.fields, (field) => field.reset());\n        this.state[setHasBeenSubmitted](false);\n        this.state[setSubmitError](null);\n    }\n}\n\nfunction lazy<T>(init: () => T) {\n    let value: T | typeof UNINITIALIZED = UNINITIALIZED;\n    return () => {\n        if (value === UNINITIALIZED) {\n            value = init();\n        }\n        return value;\n    };\n}\n\nconst UNINITIALIZED = Symbol('UNINITIALIZED');\n","import { FieldSpec, useField } from './FieldSpec';\nimport _ from 'lodash';\nimport { $Submitter, useSubmitter } from './$Submitter';\nimport { Form } from './Form';\nimport { FormProps } from '../utils/htmlProps';\nimport { useFormState } from './useFormState';\nimport { FieldSpecs } from '../utils/types';\n\nexport interface FormConfig<T = any> {\n    readonly fields: FieldSpecs<T>;\n    readonly submit: $Submitter<T>;\n    readonly props?: FormProps;\n}\n\nexport type FieldTransform<F> = <S, T>(\n    field: FieldSpec<S, T>,\n    name: string,\n    fields: FieldSpecs<F>\n) => FieldSpec<S, T>;\n\n/** @see $Form */\nclass _$Form<T> {\n    constructor(readonly config: FormConfig<T>) {}\n\n    with(config: Partial<FormConfig<T>>): $Form<T> {\n        return $Form(_.merge({}, this.config, config));\n    }\n\n    each(fieldTransform: FieldTransform<T>): $Form<T> {\n        return this.with({\n            fields: _.mapValues(\n                this.config.fields,\n                fieldTransform\n            ) as FieldSpecs<T>,\n        });\n    }\n\n    /** Makes the whole form read-only,\n     * i.e. every field become read-only and the submit button is disabled. */\n    readOnly(): $Form<T> {\n        return this.each((field) => field.readOnly()).with({\n            submit: this.config.submit.with({\n                buttonProps: { disabled: true, 'aria-disabled': true },\n            }),\n        });\n    }\n}\n\nexport type $Form<T = any> = _$Form<T>;\n\n// // eslint-disable-next-line @typescript-eslint/no-redeclare\nexport function $Form<T>(config: FormConfig<T>): $Form<T> {\n    return new _$Form<T>(config);\n}\n\n// make `$Form(...) instanceof $Form` to work\n$Form.prototype = _$Form.prototype;\n\nexport function useForm<T = any>(form: $Form<T>): Form<T> {\n    const state = useFormState();\n\n    /* Prevent the user from changing form data while submitting */\n    if (state.isSubmitting) {\n        form = form.readOnly();\n    }\n\n    const { config } = form;\n    const fields = _.mapValues(config.fields, useField) as any;\n    const submitter = useSubmitter(config.submit);\n\n    return new Form<T>(config, fields, submitter, state);\n}\n","import { FieldConfig, FieldDefaults, FieldSpec } from './FieldSpec';\nimport React, { ChangeEvent, ReactElement } from 'react';\nimport { isReactElement } from '../utils/utils';\nimport { InferS, InferT, PartialDeep } from '../utils/types';\nimport deepExtend from 'deep-extend';\nimport _ from 'lodash';\nimport { Field } from './Field';\nimport { UnwrapError, Valid } from './Result';\n\nexport interface ICustomField {\n    <S, T>(defaults: FieldDefaults<S, T>): I$CustomField<S, T>;\n\n    extends<S, T>(base: {\n        defaults: FieldDefaults<S, T>;\n    }): {\n        with(extension: PartialDeep<FieldDefaults<S, T>>): I$CustomField<S, T>;\n    };\n\n    composite<F extends Record<string, FieldSpec<any, any>>>(\n        subFields: F\n    ): {\n        with(\n            extension: PartialDeep<FieldDefaults<InferS<F>, InferT<F>>>\n        ): I$CustomField<InferS<F>, InferT<F>>;\n    };\n}\n\nexport interface I$CustomField<S, T> {\n    (config: FieldConfig<S, T>): FieldSpec<S, T>;\n\n    (label: string): FieldSpec<S, T>;\n\n    (label: ReactElement): FieldSpec<S, T>;\n\n    (label?: null | undefined): FieldSpec<S, T>;\n\n    defaults: FieldDefaults<S, T>;\n}\n\nfunction makeCustomField(): ICustomField {\n    function CustomField<S, T>(\n        defaults: FieldDefaults<S, T>\n    ): I$CustomField<S, T> {\n        function $CustomField(config: FieldConfig<S, T>): FieldSpec<S, T>;\n        function $CustomField(label: string): FieldSpec<S, T>;\n        function $CustomField(label: ReactElement): FieldSpec<S, T>;\n        function $CustomField(label?: null): FieldSpec<S, T>;\n\n        function $CustomField(\n            arg?: FieldConfig<S, T> | string | ReactElement | null\n        ): FieldSpec<S, T> {\n            // $CustomField()\n            if (arg == null) {\n                return $CustomField({});\n            }\n\n            // $CustomField(label: string)\n            if (typeof arg === 'string') {\n                return $CustomField({ label: arg });\n            }\n\n            // $CustomField(label: ReactElement)\n            if (isReactElement(arg)) {\n                return $CustomField({ label: arg });\n            }\n\n            // $CustomField(config)\n            return new FieldSpec(arg, defaults);\n        }\n\n        $CustomField.defaults = defaults;\n\n        return $CustomField;\n    }\n\n    /** Lets you define a custom field based on an existing field.\n     *\n     * For example, an $Email field can be defined as follows:\n     * ```\n     * export const $Email = CustomField.extends($Text).with({\n     *     validate(value) {\n     *         if (!value.includes('@')) {\n     *             return Invalid('Invalid email');\n     *         }\n     *         return Valid(value);\n     *     },\n     * });\n     * ```\n     *\n     * You can also extend custom builtin, the\n     * base doesn't need to be a built-in field.\n     * ``` */\n    // eslint-disable-next-line dot-notation\n    CustomField.extends = <S, T>(base: { defaults: FieldDefaults<S, T> }) => ({\n        with(extension: PartialDeep<FieldDefaults<S, T>>) {\n            return CustomField(deepExtend({}, base.defaults, extension));\n        },\n    });\n\n    CustomField.composite = <F extends Record<string, FieldSpec<any, any>>>(\n        subFields: F\n    ) => ({\n        with(extension: PartialDeep<FieldDefaults<InferS<F>, InferT<F>>>) {\n            const defaults: FieldDefaults<InferS<F>, InferT<F>> = {\n                subFields: _.mapValues(subFields, (subField, name) =>\n                    subField.with({\n                        inputProps: {\n                            onChange<S, T>(\n                                this: Field<S, T>,\n                                event: ChangeEvent<HTMLInputElement>\n                            ) {\n                                const value = event.target.value;\n                                this.superField!.input.setValue((prev: S) => ({\n                                    ...prev,\n                                    [name]: value,\n                                }));\n                            },\n\n                            onBlur<S, T>(this: Field<S, T>) {\n                                this.superField!.input.setHasBeenBlurred(true);\n                            },\n                        },\n                    })\n                ),\n\n                blankInput: _.mapValues(\n                    subFields,\n                    'defaults.blankInput'\n                ) as InferS<F>,\n\n                isBlank(this: Field<InferS<F>, InferT<F>>, inputs) {\n                    return _.some(\n                        zipValues(inputs, this.subFields),\n                        ([input, subField]) => subField.isBlank(input)\n                    );\n                },\n\n                isFocused(this: Field<InferS<F>, InferT<F>>) {\n                    return _.some(this.subFields, 'isFocused');\n                },\n\n                parse(this: Field<InferS<F>, InferT<F>>, inputs) {\n                    try {\n                        return Valid(\n                            _.chain(zipValues(inputs, this.subFields))\n                                .mapValues(([input, subField]) =>\n                                    subField.parse(input).unwrap()\n                                )\n                                .value() as InferT<F>\n                        );\n                    } catch (err) {\n                        if (err instanceof UnwrapError) return err.result;\n                        throw err;\n                    }\n                },\n\n                validate(this: Field<InferS<F>, InferT<F>>, values) {\n                    try {\n                        return Valid(\n                            _.chain(zipValues(values, this.subFields))\n                                .mapValues(([value, subField]) =>\n                                    subField.validate(value).unwrap()\n                                )\n                                .value() as InferT<F>\n                        );\n                    } catch (err) {\n                        if (err instanceof UnwrapError) return err.result;\n                        throw err;\n                    }\n                },\n\n                render: {\n                    Input({ field }) {\n                        return (\n                            <React.Fragment>\n                                {_.map(field.subFields, (subField, name) => (\n                                    <React.Fragment key={name}>\n                                        {subField.render()}\n                                    </React.Fragment>\n                                ))}\n                            </React.Fragment>\n                        );\n                    },\n                },\n            };\n\n            return CustomField<InferS<F>, InferT<F>>(\n                _.merge(defaults, extension)\n            );\n        },\n    });\n\n    return CustomField;\n}\n\nexport const CustomField = makeCustomField();\n\nfunction zipValues(\n    a: Record<string, any>,\n    b: Record<string, any>\n): Record<string, any> {\n    const ans = {};\n    Object.keys(a).forEach((key) => {\n        ans[key] = [a[key], b[key]];\n    });\n    return ans;\n}\n","import { CustomField } from '../core/CustomField';\nimport { Valid } from '../core/Result';\nimport React from 'react';\nimport _ from 'lodash';\n\nexport const checkbox = CustomField<boolean, boolean>({\n    category: 'binary',\n    blankInput: false,\n    isBlank: () => false,\n\n    parse: Valid,\n    validate: Valid,\n    acceptExternal: acceptBoolean,\n\n    inputProps: {\n        type: 'checkbox',\n    },\n\n    render: {\n        Field({ field }) {\n            const { FieldContainer, Label, Input, Message } = field.theme;\n            return (\n                <FieldContainer field={field}>\n                    <div>\n                        <Input field={field} />\n                        <Label field={field} />\n                    </div>\n                    <Message field={field} />\n                </FieldContainer>\n            );\n        },\n    },\n});\n\nexport function acceptBoolean(data: unknown): boolean | undefined {\n    if (_.isBoolean(data)) {\n        return data;\n    }\n\n    if (data === 0 || data === 1) {\n        return Boolean(data);\n    }\n\n    if (_.isString(data)) {\n        if (/^true|t|1|yes|y$/i.test(data)) {\n            return true;\n        }\n\n        if (/^false|f|0|no|n$/i.test(data)) {\n            return false;\n        }\n    }\n}\n","import React from 'react';\nimport { CustomField } from '../core/CustomField';\nimport { Set } from 'immutable';\nimport { Valid } from '../core/Result';\nimport { Field } from '../core/Field';\nimport _ from 'lodash';\nimport { acceptBoolean } from './checkbox';\n\ntype S = Set<string>;\ntype T = Set<string>;\n\nexport const checklist = CustomField<S, T>({\n    category: 'enum',\n    blankInput: Set(),\n    parse: Valid,\n    validate: Valid,\n    acceptExternal: acceptSetOfString,\n\n    optionInputProps(this: Field<S, T>, option) {\n        const { input } = this;\n\n        return {\n            type: 'checkbox',\n\n            checked: input.value.has(option.value),\n\n            onChange(event) {\n                input.setValue(toggle(event.target.value));\n            },\n        };\n    },\n\n    render: {\n        Input({ field }) {\n            return (\n                <React.Fragment>\n                    {field.options.map(\n                        ({ value, labelProps, label, inputProps }) => (\n                            <div key={value}>\n                                <input {...inputProps} />\n                                <label {...labelProps}>{label}</label>\n                            </div>\n                        )\n                    )}\n                </React.Fragment>\n            );\n        },\n    },\n});\n\nfunction acceptSetOfString(data: unknown): Set<string> | undefined {\n    /* Is it an array of some other iterable? */\n    if (Symbol.iterator in Object(data)) {\n        /* Collect all the strings in that iterable */\n        const ans = [];\n        for (const element of data as any) {\n            if (_.isString(element)) {\n                ans.push(element);\n            }\n        }\n        return Set(ans);\n    }\n\n    /* Is it something like { foo: true, bar: false }? */\n    if (_.isPlainObject(data)) {\n        return Set(\n            Object.keys(data as any).filter(\n                (key) => acceptBoolean((data as any)[key]) === true\n            )\n        );\n    }\n}\n\nfunction toggle<T>(element: T) {\n    return (set: Set<T>) =>\n        set.has(element) ? set.remove(element) : set.add(element);\n}\n","import { LocalDate, DateTimeParseException } from 'js-joda';\nimport { CustomField } from '../core/CustomField';\nimport { Invalid, Result, Valid } from '../core/Result';\nimport _ from 'lodash';\nimport { Field } from '../core/Field';\n\nexport const date = CustomField<string, LocalDate>({\n    blankInput: '',\n\n    parse(this: Field<string, LocalDate>, input: string): Result<LocalDate> {\n        try {\n            return Valid(LocalDate.parse(input));\n        } catch (err) {\n            if (err instanceof DateTimeParseException) {\n                return Invalid(this.locale.invalidDate);\n            }\n            throw err;\n        }\n    },\n\n    validate: Valid,\n    acceptExternal: acceptDate,\n\n    inputProps: {\n        type: 'date',\n        style: { display: 'block' },\n    },\n});\n\nfunction acceptDate(data: unknown): string | undefined {\n    if (data instanceof LocalDate) {\n        return data.toString();\n    }\n\n    if (_.isString(data)) {\n        data = new Date(data);\n    }\n\n    if (data instanceof Date) {\n        const input = data.toISOString().substr(0, 'YYYY-MM-DD'.length);\n        if (input !== 'Invalid Date') {\n            return input;\n        }\n    }\n}\n","import { CustomField } from '../core/CustomField';\nimport { Decimal } from 'decimal.js';\nimport { Invalid, Result, Valid } from '../core/Result';\nimport { Field } from '../core/Field';\nimport { InputProps } from '../utils/htmlProps';\nimport { removeExcessWhitespace } from '../utils/utils';\nimport _ from 'lodash';\nimport { XFormLocale } from '../core/XFormLocale';\n\nexport const decimal = CustomField<string, Decimal>({\n    category: 'numeric',\n    preprocess: removeExcessWhitespace,\n    blankInput: '',\n\n    parse(this: Field<string, Decimal>, input: string): Result<Decimal> {\n        const allowedDecimals =\n            inferAllowedDecimalsFrom(this.inputProps) ?? Infinity;\n\n        /* By default don't allow negative numbers as\n         * probably you don't want those in your forms */\n        const defaultMin = this.allowNegative ? -Infinity : 0;\n        const min = new Decimal(this.inputProps.min ?? defaultMin);\n        const max = new Decimal(this.inputProps.max ?? Infinity);\n\n        return parseDecimal(\n            input,\n            allowedDecimals,\n            min,\n            max,\n            this.nonZero,\n            this.allowNegative,\n            this.locale\n        );\n    },\n\n    validate: Valid,\n\n    acceptExternal(data) {\n        if (data instanceof Decimal || _.isNumber(data)) {\n            return data.toString();\n        }\n    },\n\n    inputProps: {\n        style: { display: 'block' },\n    },\n});\n\n/** Function that infers how many decimals are allowed\n * in a numeric field from the inputProps.\n *\n * For example, a step of 0.01 will result in 2 decimals allowed.\n *\n * It returns undefined if the number of allowed decimals cannot be inferred. */\nexport function inferAllowedDecimalsFrom(\n    inputProps: InputProps\n): number | undefined {\n    const step = Number(inputProps.step);\n    if ((1 / step) % 10 === 0) {\n        /* is step something like 0.00001? */\n        return -Math.log10(step); // count those zeros\n    }\n}\n\nexport function parseDecimal(\n    input: string,\n    allowedDecimals: number,\n    min: Decimal,\n    max: Decimal,\n    nonZero: boolean,\n    allowNegative: boolean,\n    locale: XFormLocale\n): Result<Decimal> {\n    /* Is this even a number to start with?\n     *\n     * There is a lot of computing to do afterwards, so don't dedicate\n     * too much CPU to those people that fill forms with random letters */\n    if (!floatRegex.test(input)) {\n        return Invalid(locale.invalidNumber);\n    }\n\n    /* An special message for those QA people that fill integer\n     * builtin like \"Number of children\" with decimal numbers */\n    if (!allowedDecimals && !integerRegex.test(input)) {\n        return Invalid(locale.mustBeInt);\n    }\n\n    /* Enough with the regex stuff, give me the Decimal */\n    let value: Decimal;\n    try {\n        value = new Decimal(input);\n    } catch (_pokemonException) {\n        /* Decimal.js throws a generic Error if\n         * the input is invalid so catch 'em all */\n        return Invalid(locale.invalidNumber);\n    }\n\n    /* Please no negative zeros in my yard */\n    if (value.isNegative() && value.isZero()) {\n        // If the user said '-0', just pretend to have listened '0'\n        value = new Decimal(0);\n    }\n\n    /* Another special message, this time for those whose\n     * income is pi dollars with a million decimal places */\n    if (value.decimalPlaces() > allowedDecimals) {\n        return Invalid(locale.tooManyDecimals(allowedDecimals));\n    }\n\n    if (value.lessThan(min)) {\n        return value.isNegative() && !allowNegative\n            ? Invalid(locale.negative)\n            : Invalid(locale.tooSmall(min));\n    }\n\n    if (value.greaterThan(max)) {\n        return Invalid(locale.tooBig(max));\n    }\n\n    if (nonZero && value.isZero()) {\n        return Invalid(locale.cantBeZero);\n    }\n\n    return Valid(value);\n}\n\n/* For integers, an optional sign followed by at least one digit */\nconst integerRegex = /^[-+]?\\d+$/;\n\n/* If decimals are allowed, the number format is as follows:\n * 1. an optional sign\n * 2. at least one digit for the integer part\n * 3. an optional decimal part (a dot followed by at least one digit)\n * 4. an optional exponential part\n *     (an E followed by an optional sign and some digits)\n *\n * Things like '.25' without the integer part are not valid here */\nconst floatRegex = /^[-+]?\\d+(\\.\\d+)?([Ee][-+]?\\d+)?$/;\n","import { CustomField } from '../core/CustomField';\nimport { removeExcessWhitespace } from '../utils/utils';\nimport { Result, Valid } from '../core/Result';\nimport { Field } from '../core/Field';\nimport { decimal, inferAllowedDecimalsFrom, parseDecimal } from './decimal';\nimport { Decimal } from 'decimal.js';\nimport _ from 'lodash';\n\nexport const number = CustomField<string, number>({\n    category: 'numeric',\n    preprocess: removeExcessWhitespace,\n    blankInput: '',\n\n    parse(this: Field<string, number>, input: string): Result<number> {\n        const allowedDecimals = inferAllowedDecimalsFrom(this.inputProps) ?? 0;\n\n        /* By default don't allow negative numbers as\n         * probably you don't want those in your forms */\n        const defaultMin = this.allowNegative ? -Infinity : 0;\n        const min = new Decimal(this.inputProps.min ?? defaultMin);\n        const max = new Decimal(this.inputProps.max ?? Infinity);\n\n        /* Why write a parser again for the native numbers when\n         * the Decimal parser works well? Let's reuse that wonder\n         * and just convert to a native number at the end. */\n        return parseDecimal(\n            input,\n            allowedDecimals,\n            min,\n            max,\n            this.nonZero,\n            this.allowNegative,\n            this.locale\n        ).map((decimal) => decimal.toNumber());\n    },\n\n    validate: Valid,\n\n    acceptExternal(data) {\n        if (_.isNumber(data)) {\n            return data.toString();\n        }\n    },\n\n    inputProps: decimal.defaults.inputProps,\n});\n","import { CustomField } from '../core/CustomField';\nimport { removeExcessWhitespace } from '../utils/utils';\nimport { Valid } from '../core/Result';\nimport { Field } from '../core/Field';\n\nexport const text = CustomField<string, string>({\n    category: 'textual',\n\n    preprocess(this: Field<string, string>, input: string): string {\n        // Don't remove whitespace from passwords\n        const type =\n            this.config.inputProps?.type ?? this.defaults.inputProps?.type;\n        if (type === 'password') {\n            return input;\n        }\n\n        /* Leading/trailing whitespace or 2+ consecutive\n         * spaces are in most cases accidentally typed */\n        return removeExcessWhitespace(input);\n    },\n\n    blankInput: '',\n    parse: Valid,\n    validate: Valid,\n\n    inputProps: {\n        style: { display: 'block' },\n    },\n});\n","import { text } from './text';\nimport { CustomField } from '../core/CustomField';\n\nexport const password = CustomField.extends(text).with({\n    label: 'Password',\n    inputProps: { type: 'password' },\n    preprocess: undefined, // don't trim passwords\n});\n","import { CustomField } from '../core/CustomField';\nimport React from 'react';\nimport { Option } from '../core/EnumOption';\nimport { Result, Valid } from '../core/Result';\nimport { Field } from '../core/Field';\nimport _ from 'lodash';\nimport classNames from 'classnames';\n\nexport const select = CustomField<string, Option>({\n    category: 'enum',\n    blankInput: '',\n\n    parse(this: Field<string, Option>, input: string): Result<Option> {\n        return Valid(this.input.options.find(_.matches({ value: input }))!);\n    },\n\n    validate: Valid,\n    acceptExternal: acceptOption,\n\n    inputProps: {\n        style: { display: 'block' },\n    },\n\n    render: {\n        Input({ field, className }) {\n            return (\n                <select\n                    {...(field.inputProps as any)}\n                    className={classNames(\n                        field.inputProps.className,\n                        className\n                    )}\n                >\n                    {_.isString(field.blankOption) ? (\n                        <option value=''>{field.blankOption}</option>\n                    ) : field.input.isLoading ? (\n                        <option value=''>{field.locale.loading}</option>\n                    ) : null}\n\n                    {field.options.map(({ value, label }) => (\n                        <option value={value} key={value}>\n                            {label}\n                        </option>\n                    ))}\n                </select>\n            );\n        },\n    },\n});\n\nexport function acceptOption(data: unknown): string | undefined {\n    if (_.isString((data as any).value)) {\n        return (data as any).value;\n    }\n}\n","import React from 'react';\nimport { CustomField } from '../core/CustomField';\nimport { Valid } from '../core/Result';\nimport { Option } from '../core/EnumOption';\nimport { select, acceptOption } from './select';\n\nexport const radio = CustomField<string, Option>({\n    category: 'enum',\n    blankInput: '',\n    parse: select.defaults.parse,\n    validate: Valid,\n    acceptExternal: acceptOption,\n\n    inputProps: {\n        type: 'radio',\n    },\n\n    render: {\n        Input({ field }) {\n            const { options } = field;\n            return (\n                <div>\n                    {options.map((option) => (\n                        <div key={option.value}>\n                            <input {...option.inputProps} />\n                            <label {...option.labelProps}>{option.label}</label>\n                        </div>\n                    ))}\n                </div>\n            );\n        },\n    },\n});\n","import { CustomField } from '../core/CustomField';\nimport React from 'react';\nimport { text } from './text';\n\nexport const textarea = CustomField.extends(text).with({\n    preprocess: undefined,\n\n    render: {\n        Input({ field }) {\n            return (\n                <textarea {...field.textAreaProps} ref={field.textAreaRef} />\n            );\n        },\n    },\n});\n","import { CustomField } from '../core/CustomField';\nimport { DateTimeParseException, LocalTime } from 'js-joda';\nimport { Invalid, Result, Valid } from '../core/Result';\nimport { Field } from '../core/Field';\n\nexport const time = CustomField<string, LocalTime>({\n    blankInput: '',\n\n    parse(this: Field<string, LocalTime>, input: string): Result<LocalTime> {\n        try {\n            return Valid(LocalTime.parse(input));\n        } catch (err) {\n            if (err instanceof DateTimeParseException) {\n                return Invalid(this.locale.invalidTime);\n            }\n            throw err;\n        }\n    },\n\n    validate: Valid,\n\n    acceptExternal(data) {\n        if (data instanceof LocalTime) {\n            return data.toString();\n        }\n    },\n\n    inputProps: {\n        type: 'time',\n        style: { display: 'block' },\n    },\n});\n","import { FieldSpec } from './FieldSpec';\nimport { Valid } from './Result';\n\nexport function optional<S, T>(field: FieldSpec<S, T>): FieldSpec<S, T | null> {\n    return new FieldSpec<S, T | null>(field.config, {\n        ...field.defaults,\n\n        blankResult: Valid<T | null>(null),\n    });\n}\n","import { ReactElement } from 'react';\nimport { $Submitter, OnValid, SubmitConfig } from '../core/$Submitter';\n\nexport interface ButtonSpec<T = any> {\n    readonly config: SubmitConfig<T>;\n}\n\nexport function button<T = any>(config: SubmitConfig<T>): $Submitter<T>;\nexport function button<T = any>(\n    label: string,\n    config: SubmitConfig<T>\n): $Submitter<T>;\nexport function button<T = any>(\n    label: string,\n    onValid: OnValid<T>\n): $Submitter<T>;\nexport function button<T = any>(\n    label: ReactElement,\n    config: SubmitConfig<T>\n): $Submitter<T>;\nexport function button<T = any>(\n    label: ReactElement,\n    onValid: OnValid<T>\n): $Submitter<T>;\n\nexport function button<T = any>(\n    ...args:\n        | [SubmitConfig<T>]\n        | [string | ReactElement, SubmitConfig<T> | OnValid<T>]\n): $Submitter<T> {\n    // $Button(label, onValid)\n    if (typeof args[1] === 'function') {\n        return button(args[0] as any, { onValid: args[1] });\n    }\n\n    // $Button(label, config)\n    if (args.length === 2) {\n        return button({ label: args[0], ...args[1] });\n    }\n\n    // $Button(config)\n    return new $Submitter(args[0]);\n}\n","import React from 'react';\n\nfunction Debug({ value }: { value: any }) {\n    return (\n        <pre style={{ maxWidth: '40em' }}>\n            {JSON.stringify(value, getReplacer(), '  ')}\n        </pre>\n    );\n}\n\n// based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value#Examples\nconst getReplacer = () => {\n    const seen = new WeakSet();\n    return (_key: string, value: any) => {\n        // handle react elements\n        if (\n            typeof value === 'object' &&\n            value !== null &&\n            '$$typeof' in value &&\n            value.type?.name\n        ) {\n            return `<${value.type.name}/>`;\n        }\n\n        // handle circular references\n        if (typeof value === 'object' && value !== null) {\n            if (seen.has(value)) {\n                return '...';\n            }\n            seen.add(value);\n        }\n\n        return value;\n    };\n};\n\nexport default Debug;\n"],"names":["isBeing","obj","_","isFunction","is","Result","isResultType","x","Valid","Invalid","$Valid","value","equals","other","Immutable","hashCode","hash","map","fn","chain","unwrap","_errorMessage","arg","prototype","$Invalid","message","_fn","cast","errorMessage","UnwrapError","result","Error","Option","option","label","toJSON","s","OptionWithProps","inputProps","labelProps","isReactElement","React","isValidElement","removeExcessWhitespace","input","trim","replace","single","double","quote","preferredQuote","includes","alternativeQuote","RegExp","scrollToTop","window","scrollTo","top","behavior","setForm","Symbol","describe","Field","locale","defaults","config","name","containerRef","inputRef","textAreaRef","theme","subFields","fieldIsRequired","selectAnOption","options","defaultOptions","preprocess","defaultPreprocess","isBlank","defaultIsBlank","blankResult","defaultBlankResult","blankOption","defaultBlankOption","isFocused","defaultIsFocused","showRule","defaultShowRule","merge","defaultMethods","methods","bind","parse","validate","category","nonZero","allowNegative","computeInputProps","optionInputProps","htmlFor","id","forEach","subField","superField","form","_form","blankInput","field","defaultInputProps","checked","eventHandlers","onChange","event","defaultOnChange","onFocus","defaultOnFocus","onBlur","defaultOnBlur","deepExtend","placeholder","setValue","target","_event","setIsFocused","setHasBeenBlurred","computeResult","input_","getValueAssumingItIsValid","tilde","defaultOptionInputProps","call","render","shouldBeShown","focus","element","current","console","error","fillWith","data","acceptExternal","undefined","constructor","reset","initialValue","_result","fields","getIsFocused","scrollToField","scrollIntoView","useMountEffect","effect","useEffect","useInputState","optionsObject","useState","hasBeenBlurred","isAsync","isLoading","setIsLoading","setError","parseOption","setOptions","then","defaultTheme","className","FieldContainer","Label","Input","Message","children","style","marginBottom","ref","Optional","isOptional","color","optional","classNames","hasBeenSubmitted","fontWeight","injectClassNames","injectedClassNames","mapValues","OriginalComponent","componentName","ComponentWithInjectedClassName","props","english","invalidNumber","mustBeInt","tooManyDecimals","maxDecimals","negative","tooSmall","min","tooBig","max","cantBeZero","invalidDate","invalidTime","loading","spanish","XFormContext","createContext","FieldSpec","readOnly","readOnlyIf","editable","condition","disabled","showIf","rule","useField","useContext","optionsMethod","initialInput","useRef","useMemo","setIsSubmitting","setHasBeenSubmitted","setSubmitError","useFormState","isSubmitting","setIsSubmitting_","setHasBeenSubmitted_","submitError","setSubmitError_","Submitter","onValid","onError","defaultOnError","computeButtonProps","type","onInvalid","isValid","buttonProps","submit","state","values","getValuesAssumingTheyAreValid","err","defaultOnInvalid","firstInvalidField","find","preventScroll","_buttonProps","$Submitter","useSubmitter","submitter","Form","propsFor","lazy","pickBy","every","shownFields","autoBind","onSubmit","preventDefault","key","renderFields","renderSubmit","Fragment","lazyShownFields","lazyIsValid","init","UNINITIALIZED","_$Form","$Form","each","fieldTransform","useForm","makeCustomField","CustomField","$CustomField","base","extension","composite","prev","inputs","some","zipValues","a","b","ans","Object","keys","checkbox","acceptBoolean","isBoolean","Boolean","isString","test","checklist","Set","acceptSetOfString","has","toggle","iterator","push","isPlainObject","filter","set","remove","add","date","LocalDate","DateTimeParseException","acceptDate","display","toString","Date","toISOString","substr","length","decimal","allowedDecimals","inferAllowedDecimalsFrom","Infinity","defaultMin","Decimal","parseDecimal","isNumber","step","Number","Math","log10","floatRegex","integerRegex","_pokemonException","isNegative","isZero","decimalPlaces","lessThan","greaterThan","number","toNumber","text","password","select","matches","acceptOption","radio","textarea","textAreaProps","time","LocalTime","button","Debug","maxWidth","JSON","stringify","getReplacer","seen","WeakSet","_key"],"mappings":"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"}